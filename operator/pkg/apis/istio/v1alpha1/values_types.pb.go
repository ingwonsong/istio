// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/apis/istio/v1alpha1/values_types.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Mode for the ingress controller.
type IngressControllerMode int32

const (
	// Unspecified Istio ingress controller.
	IngressControllerMode_UNSPECIFIED IngressControllerMode = 0
	// Selects all Ingress resources, with or without Istio annotation.
	IngressControllerMode_DEFAULT IngressControllerMode = 1
	// Selects only resources with istio annotation.
	IngressControllerMode_STRICT IngressControllerMode = 2
	// No ingress or sync.
	IngressControllerMode_OFF IngressControllerMode = 3
)

var IngressControllerMode_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "DEFAULT",
	2: "STRICT",
	3: "OFF",
}

var IngressControllerMode_value = map[string]int32{
	"UNSPECIFIED": 0,
	"DEFAULT":     1,
	"STRICT":      2,
	"OFF":         3,
}

func (x IngressControllerMode) String() string {
	return proto.EnumName(IngressControllerMode_name, int32(x))
}

func (IngressControllerMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{0}
}

// Specifies which tracer to use.
type Tracer int32

const (
	Tracer_zipkin          Tracer = 0
	Tracer_lightstep       Tracer = 1
	Tracer_datadog         Tracer = 2
	Tracer_stackdriver     Tracer = 3
	Tracer_openCensusAgent Tracer = 4
	Tracer_none            Tracer = 5
)

var Tracer_name = map[int32]string{
	0: "zipkin",
	1: "lightstep",
	2: "datadog",
	3: "stackdriver",
	4: "openCensusAgent",
	5: "none",
}

var Tracer_value = map[string]int32{
	"zipkin":          0,
	"lightstep":       1,
	"datadog":         2,
	"stackdriver":     3,
	"openCensusAgent": 4,
	"none":            5,
}

func (x Tracer) String() string {
	return proto.EnumName(Tracer_name, int32(x))
}

func (Tracer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{1}
}

// Specifies the sidecar's default behavior when handling outbound traffic from the application.
type OutboundTrafficPolicyConfig_Mode int32

const (
	// Outbound traffic to unknown destinations will be allowed, in case there are no services or ServiceEntries for the destination port
	OutboundTrafficPolicyConfig_ALLOW_ANY OutboundTrafficPolicyConfig_Mode = 0
	// Restrict outbound traffic to services defined in the service registry as well as those defined through ServiceEntries
	OutboundTrafficPolicyConfig_REGISTRY_ONLY OutboundTrafficPolicyConfig_Mode = 1
)

var OutboundTrafficPolicyConfig_Mode_name = map[int32]string{
	0: "ALLOW_ANY",
	1: "REGISTRY_ONLY",
}

var OutboundTrafficPolicyConfig_Mode_value = map[string]int32{
	"ALLOW_ANY":     0,
	"REGISTRY_ONLY": 1,
}

func (x OutboundTrafficPolicyConfig_Mode) String() string {
	return proto.EnumName(OutboundTrafficPolicyConfig_Mode_name, int32(x))
}

func (OutboundTrafficPolicyConfig_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{20, 0}
}

// Types of Access logs to export.
type TelemetryV2StackDriverConfig_AccessLogging int32

const (
	// No Logs.
	TelemetryV2StackDriverConfig_NONE TelemetryV2StackDriverConfig_AccessLogging = 0
	// All logs including both success and error logs.
	TelemetryV2StackDriverConfig_FULL TelemetryV2StackDriverConfig_AccessLogging = 1
	// All error logs. This is currently only available for outbound/client side
	// logs. A request is classified as error when `status>=400 or
	// response_flag != "-"`
	TelemetryV2StackDriverConfig_ERRORS_ONLY TelemetryV2StackDriverConfig_AccessLogging = 2
)

var TelemetryV2StackDriverConfig_AccessLogging_name = map[int32]string{
	0: "NONE",
	1: "FULL",
	2: "ERRORS_ONLY",
}

var TelemetryV2StackDriverConfig_AccessLogging_value = map[string]int32{
	"NONE":        0,
	"FULL":        1,
	"ERRORS_ONLY": 2,
}

func (x TelemetryV2StackDriverConfig_AccessLogging) String() string {
	return proto.EnumName(TelemetryV2StackDriverConfig_AccessLogging_name, int32(x))
}

func (TelemetryV2StackDriverConfig_AccessLogging) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{29, 0}
}

// ArchConfig specifies the pod scheduling target architecture(amd64, ppc64le, s390x, arm64)
// for all the Istio control plane components.
type ArchConfig struct {
	// Sets pod scheduling weight for amd64 arch
	Amd64 uint32 `protobuf:"varint,1,opt,name=amd64,proto3" json:"amd64,omitempty"`
	// Sets pod scheduling weight for ppc64le arch.
	Ppc64Le uint32 `protobuf:"varint,2,opt,name=ppc64le,proto3" json:"ppc64le,omitempty"`
	// Sets pod scheduling weight for s390x arch.
	S390X uint32 `protobuf:"varint,3,opt,name=s390x,proto3" json:"s390x,omitempty"`
	// Sets pod scheduling weight for arm64 arch.
	Arm64                uint32   `protobuf:"varint,4,opt,name=arm64,proto3" json:"arm64,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArchConfig) Reset()         { *m = ArchConfig{} }
func (m *ArchConfig) String() string { return proto.CompactTextString(m) }
func (*ArchConfig) ProtoMessage()    {}
func (*ArchConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{0}
}
func (m *ArchConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchConfig.Merge(m, src)
}
func (m *ArchConfig) XXX_Size() int {
	return m.Size()
}
func (m *ArchConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ArchConfig proto.InternalMessageInfo

func (m *ArchConfig) GetAmd64() uint32 {
	if m != nil {
		return m.Amd64
	}
	return 0
}

func (m *ArchConfig) GetPpc64Le() uint32 {
	if m != nil {
		return m.Ppc64Le
	}
	return 0
}

func (m *ArchConfig) GetS390X() uint32 {
	if m != nil {
		return m.S390X
	}
	return 0
}

func (m *ArchConfig) GetArm64() uint32 {
	if m != nil {
		return m.Arm64
	}
	return 0
}

// Configuration for CNI.
type CNIConfig struct {
	// Controls whether CNI is enabled.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Hub                  string           `protobuf:"bytes,2,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag                  *types.Value     `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"`
	Image                string           `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	PullPolicy           string           `protobuf:"bytes,5,opt,name=pullPolicy,proto3" json:"pullPolicy,omitempty"`
	CniBinDir            string           `protobuf:"bytes,6,opt,name=cniBinDir,proto3" json:"cniBinDir,omitempty"`
	CniConfDir           string           `protobuf:"bytes,7,opt,name=cniConfDir,proto3" json:"cniConfDir,omitempty"`
	CniConfFileName      string           `protobuf:"bytes,8,opt,name=cniConfFileName,proto3" json:"cniConfFileName,omitempty"`
	ExcludeNamespaces    []string         `protobuf:"bytes,9,rep,name=excludeNamespaces,proto3" json:"excludeNamespaces,omitempty"`
	PodAnnotations       *types.Struct    `protobuf:"bytes,10,opt,name=podAnnotations,proto3" json:"podAnnotations,omitempty"` // Deprecated: Do not use.
	PspClusterRole       string           `protobuf:"bytes,11,opt,name=psp_cluster_role,json=pspClusterRole,proto3" json:"psp_cluster_role,omitempty"`
	LogLevel             string           `protobuf:"bytes,12,opt,name=logLevel,proto3" json:"logLevel,omitempty"`
	Repair               *CNIRepairConfig `protobuf:"bytes,13,opt,name=repair,proto3" json:"repair,omitempty"`
	Chained              *types.BoolValue `protobuf:"bytes,14,opt,name=chained,proto3" json:"chained,omitempty"`
	Taint                *CNITaintConfig  `protobuf:"bytes,15,opt,name=taint,proto3" json:"taint,omitempty"`
	ResourceQuotas       *ResourceQuotas  `protobuf:"bytes,16,opt,name=resource_quotas,json=resourceQuotas,proto3" json:"resource_quotas,omitempty"`
	Resources            *Resources       `protobuf:"bytes,17,opt,name=resources,proto3" json:"resources,omitempty"`
	Privileged           *types.BoolValue `protobuf:"bytes,18,opt,name=privileged,proto3" json:"privileged,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CNIConfig) Reset()         { *m = CNIConfig{} }
func (m *CNIConfig) String() string { return proto.CompactTextString(m) }
func (*CNIConfig) ProtoMessage()    {}
func (*CNIConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{1}
}
func (m *CNIConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNIConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNIConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNIConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNIConfig.Merge(m, src)
}
func (m *CNIConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNIConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNIConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNIConfig proto.InternalMessageInfo

func (m *CNIConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *CNIConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *CNIConfig) GetTag() *types.Value {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *CNIConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *CNIConfig) GetPullPolicy() string {
	if m != nil {
		return m.PullPolicy
	}
	return ""
}

func (m *CNIConfig) GetCniBinDir() string {
	if m != nil {
		return m.CniBinDir
	}
	return ""
}

func (m *CNIConfig) GetCniConfDir() string {
	if m != nil {
		return m.CniConfDir
	}
	return ""
}

func (m *CNIConfig) GetCniConfFileName() string {
	if m != nil {
		return m.CniConfFileName
	}
	return ""
}

func (m *CNIConfig) GetExcludeNamespaces() []string {
	if m != nil {
		return m.ExcludeNamespaces
	}
	return nil
}

// Deprecated: Do not use.
func (m *CNIConfig) GetPodAnnotations() *types.Struct {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *CNIConfig) GetPspClusterRole() string {
	if m != nil {
		return m.PspClusterRole
	}
	return ""
}

func (m *CNIConfig) GetLogLevel() string {
	if m != nil {
		return m.LogLevel
	}
	return ""
}

func (m *CNIConfig) GetRepair() *CNIRepairConfig {
	if m != nil {
		return m.Repair
	}
	return nil
}

func (m *CNIConfig) GetChained() *types.BoolValue {
	if m != nil {
		return m.Chained
	}
	return nil
}

func (m *CNIConfig) GetTaint() *CNITaintConfig {
	if m != nil {
		return m.Taint
	}
	return nil
}

func (m *CNIConfig) GetResourceQuotas() *ResourceQuotas {
	if m != nil {
		return m.ResourceQuotas
	}
	return nil
}

func (m *CNIConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *CNIConfig) GetPrivileged() *types.BoolValue {
	if m != nil {
		return m.Privileged
	}
	return nil
}

type CNITaintConfig struct {
	// Controls whether taint behavior is enabled.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CNITaintConfig) Reset()         { *m = CNITaintConfig{} }
func (m *CNITaintConfig) String() string { return proto.CompactTextString(m) }
func (*CNITaintConfig) ProtoMessage()    {}
func (*CNITaintConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{2}
}
func (m *CNITaintConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNITaintConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNITaintConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNITaintConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNITaintConfig.Merge(m, src)
}
func (m *CNITaintConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNITaintConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNITaintConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNITaintConfig proto.InternalMessageInfo

func (m *CNITaintConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

type CNIRepairConfig struct {
	// Controls whether repair behavior is enabled.
	Enabled *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Hub     string           `protobuf:"bytes,2,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag     *types.Value     `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"`
	Image   string           `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	// Controls whether various repair behaviors are enabled.
	LabelPods            bool     `protobuf:"varint,5,opt,name=labelPods,proto3" json:"labelPods,omitempty"`
	CreateEvents         string   `protobuf:"bytes,6,opt,name=createEvents,proto3" json:"createEvents,omitempty"` // Deprecated: Do not use.
	DeletePods           bool     `protobuf:"varint,7,opt,name=deletePods,proto3" json:"deletePods,omitempty"`
	BrokenPodLabelKey    string   `protobuf:"bytes,8,opt,name=brokenPodLabelKey,proto3" json:"brokenPodLabelKey,omitempty"`
	BrokenPodLabelValue  string   `protobuf:"bytes,9,opt,name=brokenPodLabelValue,proto3" json:"brokenPodLabelValue,omitempty"`
	InitContainerName    string   `protobuf:"bytes,10,opt,name=initContainerName,proto3" json:"initContainerName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CNIRepairConfig) Reset()         { *m = CNIRepairConfig{} }
func (m *CNIRepairConfig) String() string { return proto.CompactTextString(m) }
func (*CNIRepairConfig) ProtoMessage()    {}
func (*CNIRepairConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{3}
}
func (m *CNIRepairConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNIRepairConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNIRepairConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNIRepairConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNIRepairConfig.Merge(m, src)
}
func (m *CNIRepairConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNIRepairConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNIRepairConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNIRepairConfig proto.InternalMessageInfo

func (m *CNIRepairConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *CNIRepairConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *CNIRepairConfig) GetTag() *types.Value {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *CNIRepairConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *CNIRepairConfig) GetLabelPods() bool {
	if m != nil {
		return m.LabelPods
	}
	return false
}

// Deprecated: Do not use.
func (m *CNIRepairConfig) GetCreateEvents() string {
	if m != nil {
		return m.CreateEvents
	}
	return ""
}

func (m *CNIRepairConfig) GetDeletePods() bool {
	if m != nil {
		return m.DeletePods
	}
	return false
}

func (m *CNIRepairConfig) GetBrokenPodLabelKey() string {
	if m != nil {
		return m.BrokenPodLabelKey
	}
	return ""
}

func (m *CNIRepairConfig) GetBrokenPodLabelValue() string {
	if m != nil {
		return m.BrokenPodLabelValue
	}
	return ""
}

func (m *CNIRepairConfig) GetInitContainerName() string {
	if m != nil {
		return m.InitContainerName
	}
	return ""
}

type ResourceQuotas struct {
	// Controls whether to create resource quotas or not for the CNI DaemonSet.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Pods                 int64            `protobuf:"varint,2,opt,name=pods,proto3" json:"pods,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ResourceQuotas) Reset()         { *m = ResourceQuotas{} }
func (m *ResourceQuotas) String() string { return proto.CompactTextString(m) }
func (*ResourceQuotas) ProtoMessage()    {}
func (*ResourceQuotas) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{4}
}
func (m *ResourceQuotas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceQuotas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceQuotas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceQuotas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceQuotas.Merge(m, src)
}
func (m *ResourceQuotas) XXX_Size() int {
	return m.Size()
}
func (m *ResourceQuotas) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceQuotas.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceQuotas proto.InternalMessageInfo

func (m *ResourceQuotas) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *ResourceQuotas) GetPods() int64 {
	if m != nil {
		return m.Pods
	}
	return 0
}

// Configuration for CPU target utilization for HorizontalPodAutoscaler target.
type CPUTargetUtilizationConfig struct {
	// K8s utilization setting for HorizontalPodAutoscaler target.
	//
	// See https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	TargetAverageUtilization int32    `protobuf:"varint,1,opt,name=targetAverageUtilization,proto3" json:"targetAverageUtilization,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CPUTargetUtilizationConfig) Reset()         { *m = CPUTargetUtilizationConfig{} }
func (m *CPUTargetUtilizationConfig) String() string { return proto.CompactTextString(m) }
func (*CPUTargetUtilizationConfig) ProtoMessage()    {}
func (*CPUTargetUtilizationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{5}
}
func (m *CPUTargetUtilizationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUTargetUtilizationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUTargetUtilizationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUTargetUtilizationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUTargetUtilizationConfig.Merge(m, src)
}
func (m *CPUTargetUtilizationConfig) XXX_Size() int {
	return m.Size()
}
func (m *CPUTargetUtilizationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUTargetUtilizationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CPUTargetUtilizationConfig proto.InternalMessageInfo

func (m *CPUTargetUtilizationConfig) GetTargetAverageUtilization() int32 {
	if m != nil {
		return m.TargetAverageUtilization
	}
	return 0
}

// Mirrors Resources for unmarshaling.
type Resources struct {
	Limits               map[string]string `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Requests             map[string]string `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{6}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Resources) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Mirrors ServiceAccount for unmarshaling.
type ServiceAccount struct {
	Annotations          *types.Struct `protobuf:"bytes,1,opt,name=annotations,proto3" json:"annotations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ServiceAccount) Reset()         { *m = ServiceAccount{} }
func (m *ServiceAccount) String() string { return proto.CompactTextString(m) }
func (*ServiceAccount) ProtoMessage()    {}
func (*ServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{7}
}
func (m *ServiceAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAccount.Merge(m, src)
}
func (m *ServiceAccount) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAccount proto.InternalMessageInfo

func (m *ServiceAccount) GetAnnotations() *types.Struct {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// DefaultPodDisruptionBudgetConfig specifies the default pod disruption budget configuration.
//
// See https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
type DefaultPodDisruptionBudgetConfig struct {
	// Controls whether a PodDisruptionBudget with a default minAvailable value of 1 is created for each deployment.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DefaultPodDisruptionBudgetConfig) Reset()         { *m = DefaultPodDisruptionBudgetConfig{} }
func (m *DefaultPodDisruptionBudgetConfig) String() string { return proto.CompactTextString(m) }
func (*DefaultPodDisruptionBudgetConfig) ProtoMessage()    {}
func (*DefaultPodDisruptionBudgetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{8}
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultPodDisruptionBudgetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultPodDisruptionBudgetConfig.Merge(m, src)
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Size() int {
	return m.Size()
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultPodDisruptionBudgetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultPodDisruptionBudgetConfig proto.InternalMessageInfo

func (m *DefaultPodDisruptionBudgetConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

// DefaultResourcesConfig specifies the default k8s resources settings for all Istio control plane components.
type DefaultResourcesConfig struct {
	// k8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Requests             *ResourcesRequestsConfig `protobuf:"bytes,1,opt,name=requests,proto3" json:"requests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DefaultResourcesConfig) Reset()         { *m = DefaultResourcesConfig{} }
func (m *DefaultResourcesConfig) String() string { return proto.CompactTextString(m) }
func (*DefaultResourcesConfig) ProtoMessage()    {}
func (*DefaultResourcesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{9}
}
func (m *DefaultResourcesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultResourcesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultResourcesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultResourcesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultResourcesConfig.Merge(m, src)
}
func (m *DefaultResourcesConfig) XXX_Size() int {
	return m.Size()
}
func (m *DefaultResourcesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultResourcesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultResourcesConfig proto.InternalMessageInfo

func (m *DefaultResourcesConfig) GetRequests() *ResourcesRequestsConfig {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Configuration for an egress gateway.
type EgressGatewayConfig struct {
	// Controls whether auto scaling with a HorizontalPodAutoscaler is enabled.
	AutoscaleEnabled *types.BoolValue `protobuf:"bytes,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	// maxReplicas setting for HorizontalPodAutoscaler.
	AutoscaleMax uint32 `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	// minReplicas setting for HorizontalPodAutoscaler.
	AutoscaleMin uint32 `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	// K8s utilization setting for HorizontalPodAutoscaler target.
	//
	// See https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	Cpu *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"` // Deprecated: Do not use.
	// Controls whether an egress gateway is enabled.
	Enabled *types.BoolValue `protobuf:"bytes,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Environment variables passed to the proxy container.
	Env    *types.Struct     `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty"`
	Labels map[string]string `protobuf:"bytes,9,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Name   string            `protobuf:"bytes,25,opt,name=name,proto3" json:"name,omitempty"`
	// K8s node selector.
	//
	// See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector *types.Struct `protobuf:"bytes,10,opt,name=nodeSelector,proto3" json:"nodeSelector,omitempty"` // Deprecated: Do not use.
	// K8s annotations for pods.
	//
	// See: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations *types.Struct `protobuf:"bytes,11,opt,name=podAnnotations,proto3" json:"podAnnotations,omitempty"` // Deprecated: Do not use.
	// Pod anti-affinity label selector.
	//
	// Specify the pod anti-affinity that allows you to constrain which nodes
	// your pod is eligible to be scheduled based on labels on pods that are
	// already running on the node rather than based on labels on nodes.
	// There are currently two types of anti-affinity:
	//    "requiredDuringSchedulingIgnoredDuringExecution"
	//    "preferredDuringSchedulingIgnoredDuringExecution"
	// which denote “hard” vs. “soft” requirements, you can define your values
	// in "podAntiAffinityLabelSelector" and "podAntiAffinityTermLabelSelector"
	// correspondingly.
	// See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
	//
	// Examples:
	// podAntiAffinityLabelSelector:
	//  - key: security
	//    operator: In
	//    values: S1,S2
	//    topologyKey: "kubernetes.io/hostname"
	//  This pod anti-affinity rule says that the pod requires not to be scheduled
	//  onto a node if that node is already running a pod with label having key
	//  “security” and value “S1”.
	PodAntiAffinityLabelSelector []*types.Struct `protobuf:"bytes,12,rep,name=podAntiAffinityLabelSelector,proto3" json:"podAntiAffinityLabelSelector,omitempty"` // Deprecated: Do not use.
	// See PodAntiAffinityLabelSelector.
	PodAntiAffinityTermLabelSelector []*types.Struct `protobuf:"bytes,13,rep,name=podAntiAffinityTermLabelSelector,proto3" json:"podAntiAffinityTermLabelSelector,omitempty"` // Deprecated: Do not use.
	// Ports Configuration for the egress gateway service.
	Ports []*PortsConfig `protobuf:"bytes,14,rep,name=ports,proto3" json:"ports,omitempty"`
	// K8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *Resources `protobuf:"bytes,15,opt,name=resources,proto3" json:"resources,omitempty"` // Deprecated: Do not use.
	// Config for secret volume mounts.
	SecretVolumes []*SecretVolume `protobuf:"bytes,16,rep,name=secretVolumes,proto3" json:"secretVolumes,omitempty"`
	// Annotations to add to the egress gateway service.
	ServiceAnnotations *types.Struct `protobuf:"bytes,17,opt,name=serviceAnnotations,proto3" json:"serviceAnnotations,omitempty"`
	// Service type.
	//
	// See https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type string `protobuf:"bytes,18,opt,name=type,proto3" json:"type,omitempty"`
	// Enables cross-cluster access using SNI matching.
	Zvpn        *ZeroVPNConfig  `protobuf:"bytes,19,opt,name=zvpn,proto3" json:"zvpn,omitempty"`
	Tolerations []*types.Struct `protobuf:"bytes,20,rep,name=tolerations,proto3" json:"tolerations,omitempty"` // Deprecated: Do not use.
	// K8s rolling update strategy
	RollingMaxSurge *IntOrString `protobuf:"bytes,21,opt,name=rollingMaxSurge,proto3" json:"rollingMaxSurge,omitempty"` // Deprecated: Do not use.
	// K8s rolling update strategy
	RollingMaxUnavailable *IntOrString     `protobuf:"bytes,22,opt,name=rollingMaxUnavailable,proto3" json:"rollingMaxUnavailable,omitempty"` // Deprecated: Do not use.
	ConfigVolumes         []*types.Struct  `protobuf:"bytes,23,rep,name=configVolumes,proto3" json:"configVolumes,omitempty"`
	AdditionalContainers  []*types.Struct  `protobuf:"bytes,24,rep,name=additionalContainers,proto3" json:"additionalContainers,omitempty"`
	RunAsRoot             *types.BoolValue `protobuf:"bytes,26,opt,name=runAsRoot,proto3" json:"runAsRoot,omitempty"`
	// The injection template to use for the gateway. If not set, no injection will be performed.
	InjectionTemplate    string          `protobuf:"bytes,27,opt,name=injectionTemplate,proto3" json:"injectionTemplate,omitempty"`
	ServiceAccount       *ServiceAccount `protobuf:"bytes,28,opt,name=serviceAccount,proto3" json:"serviceAccount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EgressGatewayConfig) Reset()         { *m = EgressGatewayConfig{} }
func (m *EgressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*EgressGatewayConfig) ProtoMessage()    {}
func (*EgressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{10}
}
func (m *EgressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewayConfig.Merge(m, src)
}
func (m *EgressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewayConfig proto.InternalMessageInfo

func (m *EgressGatewayConfig) GetAutoscaleEnabled() *types.BoolValue {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return nil
}

func (m *EgressGatewayConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *EgressGatewayConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *EgressGatewayConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *EgressGatewayConfig) GetEnv() *types.Struct {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *EgressGatewayConfig) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *EgressGatewayConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetNodeSelector() *types.Struct {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetPodAnnotations() *types.Struct {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetPodAntiAffinityLabelSelector() []*types.Struct {
	if m != nil {
		return m.PodAntiAffinityLabelSelector
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetPodAntiAffinityTermLabelSelector() []*types.Struct {
	if m != nil {
		return m.PodAntiAffinityTermLabelSelector
	}
	return nil
}

func (m *EgressGatewayConfig) GetPorts() []*PortsConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *EgressGatewayConfig) GetSecretVolumes() []*SecretVolume {
	if m != nil {
		return m.SecretVolumes
	}
	return nil
}

func (m *EgressGatewayConfig) GetServiceAnnotations() *types.Struct {
	if m != nil {
		return m.ServiceAnnotations
	}
	return nil
}

func (m *EgressGatewayConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *EgressGatewayConfig) GetZvpn() *ZeroVPNConfig {
	if m != nil {
		return m.Zvpn
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetTolerations() []*types.Struct {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetRollingMaxSurge() *IntOrString {
	if m != nil {
		return m.RollingMaxSurge
	}
	return nil
}

// Deprecated: Do not use.
func (m *EgressGatewayConfig) GetRollingMaxUnavailable() *IntOrString {
	if m != nil {
		return m.RollingMaxUnavailable
	}
	return nil
}

func (m *EgressGatewayConfig) GetConfigVolumes() []*types.Struct {
	if m != nil {
		return m.ConfigVolumes
	}
	return nil
}

func (m *EgressGatewayConfig) GetAdditionalContainers() []*types.Struct {
	if m != nil {
		return m.AdditionalContainers
	}
	return nil
}

func (m *EgressGatewayConfig) GetRunAsRoot() *types.BoolValue {
	if m != nil {
		return m.RunAsRoot
	}
	return nil
}

func (m *EgressGatewayConfig) GetInjectionTemplate() string {
	if m != nil {
		return m.InjectionTemplate
	}
	return ""
}

func (m *EgressGatewayConfig) GetServiceAccount() *ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

// Configuration for gateways.
type GatewaysConfig struct {
	// Configuration for an egress gateway.
	IstioEgressgateway *EgressGatewayConfig `protobuf:"bytes,1,opt,name=istio_egressgateway,json=istio-egressgateway,proto3" json:"istio_egressgateway,omitempty"`
	// Controls whether any gateways are enabled.
	Enabled *types.BoolValue `protobuf:"bytes,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Configuration for an ingress gateway.
	IstioIngressgateway  *IngressGatewayConfig `protobuf:"bytes,4,opt,name=istio_ingressgateway,json=istio-ingressgateway,proto3" json:"istio_ingressgateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GatewaysConfig) Reset()         { *m = GatewaysConfig{} }
func (m *GatewaysConfig) String() string { return proto.CompactTextString(m) }
func (*GatewaysConfig) ProtoMessage()    {}
func (*GatewaysConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{11}
}
func (m *GatewaysConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewaysConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewaysConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewaysConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewaysConfig.Merge(m, src)
}
func (m *GatewaysConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewaysConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewaysConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewaysConfig proto.InternalMessageInfo

func (m *GatewaysConfig) GetIstioEgressgateway() *EgressGatewayConfig {
	if m != nil {
		return m.IstioEgressgateway
	}
	return nil
}

func (m *GatewaysConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *GatewaysConfig) GetIstioIngressgateway() *IngressGatewayConfig {
	if m != nil {
		return m.IstioIngressgateway
	}
	return nil
}

// Global Configuration for Istio components.
type GlobalConfig struct {
	// Specifies pod scheduling arch(amd64, ppc64le, s390x, arm64) and weight as follows:
	//   0 - Never scheduled
	//   1 - Least preferred
	//   2 - No preference
	//   3 - Most preferred
	//
	// Deprecated: replaced by the affinity k8s settings which allows architecture nodeAffinity configuration of this behavior.
	Arch                *ArchConfig `protobuf:"bytes,1,opt,name=arch,proto3" json:"arch,omitempty"` // Deprecated: Do not use.
	ConfigRootNamespace string      `protobuf:"bytes,50,opt,name=configRootNamespace,proto3" json:"configRootNamespace,omitempty"`
	// Controls whether the server-side validation is enabled.
	ConfigValidation                *types.BoolValue `protobuf:"bytes,3,opt,name=configValidation,proto3" json:"configValidation,omitempty"`
	DefaultConfigVisibilitySettings []string         `protobuf:"bytes,52,rep,name=defaultConfigVisibilitySettings,proto3" json:"defaultConfigVisibilitySettings,omitempty"`
	// Default k8s node selector for all the Istio control plane components
	//
	// See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	DefaultNodeSelector *types.Struct `protobuf:"bytes,6,opt,name=defaultNodeSelector,proto3" json:"defaultNodeSelector,omitempty"` // Deprecated: Do not use.
	// Specifies the default pod disruption budget configuration.
	DefaultPodDisruptionBudget *DefaultPodDisruptionBudgetConfig `protobuf:"bytes,7,opt,name=defaultPodDisruptionBudget,proto3" json:"defaultPodDisruptionBudget,omitempty"` // Deprecated: Do not use.
	// Default k8s resources settings for all Istio control plane components.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	DefaultResources   *DefaultResourcesConfig `protobuf:"bytes,9,opt,name=defaultResources,proto3" json:"defaultResources,omitempty"`      // Deprecated: Do not use.
	DefaultTolerations []*types.Struct         `protobuf:"bytes,55,rep,name=defaultTolerations,proto3" json:"defaultTolerations,omitempty"` // Deprecated: Do not use.
	// Specifies the docker hub for Istio images.
	Hub string `protobuf:"bytes,12,opt,name=hub,proto3" json:"hub,omitempty"`
	// Specifies the image pull policy for the Istio images. one of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated.
	//
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	ImagePullPolicy  string   `protobuf:"bytes,13,opt,name=imagePullPolicy,proto3" json:"imagePullPolicy,omitempty"`
	ImagePullSecrets []string `protobuf:"bytes,37,rep,name=imagePullSecrets,proto3" json:"imagePullSecrets,omitempty"`
	// Specifies the default namespace for the Istio control plane components.
	IstioNamespace string           `protobuf:"bytes,14,opt,name=istioNamespace,proto3" json:"istioNamespace,omitempty"`
	LogAsJson      *types.BoolValue `protobuf:"bytes,36,opt,name=logAsJson,proto3" json:"logAsJson,omitempty"`
	// Specifies the global logging level settings for the Istio control plane components.
	Logging *GlobalLoggingConfig `protobuf:"bytes,17,opt,name=logging,proto3" json:"logging,omitempty"`
	MeshID  string               `protobuf:"bytes,53,opt,name=meshID,proto3" json:"meshID,omitempty"`
	// Configure the mesh networks to be used by the Split Horizon EDS.
	//
	// The following example defines two networks with different endpoints association methods.
	// For `network1` all endpoints that their IP belongs to the provided CIDR range will be
	// mapped to network1. The gateway for this network example is specified by its public IP
	// address and port.
	// The second network, `network2`, in this example is defined differently with all endpoints
	// retrieved through the specified Multi-Cluster registry being mapped to network2. The
	// gateway is also defined differently with the name of the gateway service on the remote
	// cluster. The public IP for the gateway will be determined from that remote service (only
	// LoadBalancer gateway service type is currently supported, for a NodePort type gateway service,
	// it still need to be configured manually).
	//
	// meshNetworks:
	//   network1:
	//     endpoints:
	//     - fromCidr: "192.168.0.1/24"
	//     gateways:
	//     - address: 1.1.1.1
	//       port: 80
	//   network2:
	//     endpoints:
	//     - fromRegistry: reg1
	//     gateways:
	//     - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
	//       port: 443
	//
	MeshNetworks *types.Struct `protobuf:"bytes,19,opt,name=meshNetworks,proto3" json:"meshNetworks,omitempty"`
	// Specifies the Configuration for Istio mesh across multiple clusters through Istio gateways.
	MultiCluster *MultiClusterConfig `protobuf:"bytes,22,opt,name=multiCluster,proto3" json:"multiCluster,omitempty"`
	Network      string              `protobuf:"bytes,39,opt,name=network,proto3" json:"network,omitempty"`
	// Custom DNS config for the pod to resolve names of services in other
	// clusters. Use this to add additional search domains, and other settings.
	// see https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#dns-config
	// This does not apply to gateway pods as they typically need a different
	// set of DNS settings than the normal application pods (e.g. in multicluster scenarios).
	PodDNSSearchNamespaces       []string         `protobuf:"bytes,43,rep,name=podDNSSearchNamespaces,proto3" json:"podDNSSearchNamespaces,omitempty"`
	OmitSidecarInjectorConfigMap *types.BoolValue `protobuf:"bytes,38,opt,name=omitSidecarInjectorConfigMap,proto3" json:"omitSidecarInjectorConfigMap,omitempty"`
	// Controls whether to restrict the applications namespace the controller manages;
	// If set it to false, the controller watches all namespaces.
	OneNamespace           *types.BoolValue `protobuf:"bytes,23,opt,name=oneNamespace,proto3" json:"oneNamespace,omitempty"`
	OperatorManageWebhooks *types.BoolValue `protobuf:"bytes,41,opt,name=operatorManageWebhooks,proto3" json:"operatorManageWebhooks,omitempty"`
	// Specifies the k8s priorityClassName for the istio control plane components.
	//
	// See https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
	PriorityClassName string `protobuf:"bytes,27,opt,name=priorityClassName,proto3" json:"priorityClassName,omitempty"` // Deprecated: Do not use.
	// Specifies how proxies are configured within Istio.
	Proxy *ProxyConfig `protobuf:"bytes,28,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// Specifies the Configuration for proxy_init container which sets the pods' networking to intercept the inbound/outbound traffic.
	ProxyInit *ProxyInitConfig `protobuf:"bytes,29,opt,name=proxyInit,json=proxy_init,proto3" json:"proxy_init,omitempty"`
	// Specifies the Configuration for the SecretDiscoveryService instead of using K8S secrets to mount the certificates.
	Sds *SDSConfig `protobuf:"bytes,30,opt,name=sds,proto3" json:"sds,omitempty"`
	// Specifies the tag for the Istio docker images.
	Tag *types.Value `protobuf:"bytes,31,opt,name=tag,proto3" json:"tag,omitempty"`
	// Specifies the Configuration for each of the supported tracers.
	Tracer *TracerConfig `protobuf:"bytes,33,opt,name=tracer,proto3" json:"tracer,omitempty"`
	// Controls whether to use of Mesh Configuration Protocol to distribute configuration.
	UseMCP *types.BoolValue `protobuf:"bytes,35,opt,name=useMCP,proto3" json:"useMCP,omitempty"`
	// Specifies the Istio control plane’s pilot Pod IP address or remote cluster DNS resolvable hostname.
	RemotePilotAddress string `protobuf:"bytes,48,opt,name=remotePilotAddress,proto3" json:"remotePilotAddress,omitempty"`
	// Specifies the configution of istiod
	Istiod *IstiodConfig `protobuf:"bytes,54,opt,name=istiod,proto3" json:"istiod,omitempty"`
	// Configure the Pilot certificate provider.
	// Currently, four providers are supported: "kubernetes", "istiod", "custom" and "none".
	PilotCertProvider string `protobuf:"bytes,56,opt,name=pilotCertProvider,proto3" json:"pilotCertProvider,omitempty"`
	// Configure the policy for validating JWT.
	// Currently, two options are supported: "third-party-jwt" and "first-party-jwt".
	JwtPolicy string `protobuf:"bytes,57,opt,name=jwtPolicy,proto3" json:"jwtPolicy,omitempty"`
	// Specifies the configuration for Security Token Service.
	Sts *STSConfig `protobuf:"bytes,58,opt,name=sts,proto3" json:"sts,omitempty"`
	// Configures the revision this control plane is a part of
	Revision string `protobuf:"bytes,59,opt,name=revision,proto3" json:"revision,omitempty"`
	// Controls whether the in-cluster MTLS key and certs are loaded from the secret volume mounts.
	MountMtlsCerts *types.BoolValue `protobuf:"bytes,60,opt,name=mountMtlsCerts,proto3" json:"mountMtlsCerts,omitempty"`
	// The address of the CA for CSR.
	CaAddress string `protobuf:"bytes,61,opt,name=caAddress,proto3" json:"caAddress,omitempty"`
	// Controls whether one external istiod is enabled.
	ExternalIstiod *types.BoolValue `protobuf:"bytes,62,opt,name=externalIstiod,proto3" json:"externalIstiod,omitempty"`
	// Controls whether a remote cluster is the config cluster for an external istiod
	ConfigCluster *types.BoolValue `protobuf:"bytes,64,opt,name=configCluster,proto3" json:"configCluster,omitempty"`
	// The name of the CA for workloads.
	// For example, when caName=GkeWorkloadCertificate, GKE workload certificates
	// will be used as the certificates for workloads.
	// The default value is "" and when caName="", the CA will be configured by other
	// mechanisms (e.g., environmental variable CA_PROVIDER).
	CaName               string   `protobuf:"bytes,65,opt,name=caName,proto3" json:"caName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalConfig) Reset()         { *m = GlobalConfig{} }
func (m *GlobalConfig) String() string { return proto.CompactTextString(m) }
func (*GlobalConfig) ProtoMessage()    {}
func (*GlobalConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{12}
}
func (m *GlobalConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalConfig.Merge(m, src)
}
func (m *GlobalConfig) XXX_Size() int {
	return m.Size()
}
func (m *GlobalConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalConfig proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *GlobalConfig) GetArch() *ArchConfig {
	if m != nil {
		return m.Arch
	}
	return nil
}

func (m *GlobalConfig) GetConfigRootNamespace() string {
	if m != nil {
		return m.ConfigRootNamespace
	}
	return ""
}

func (m *GlobalConfig) GetConfigValidation() *types.BoolValue {
	if m != nil {
		return m.ConfigValidation
	}
	return nil
}

func (m *GlobalConfig) GetDefaultConfigVisibilitySettings() []string {
	if m != nil {
		return m.DefaultConfigVisibilitySettings
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalConfig) GetDefaultNodeSelector() *types.Struct {
	if m != nil {
		return m.DefaultNodeSelector
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalConfig) GetDefaultPodDisruptionBudget() *DefaultPodDisruptionBudgetConfig {
	if m != nil {
		return m.DefaultPodDisruptionBudget
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalConfig) GetDefaultResources() *DefaultResourcesConfig {
	if m != nil {
		return m.DefaultResources
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalConfig) GetDefaultTolerations() []*types.Struct {
	if m != nil {
		return m.DefaultTolerations
	}
	return nil
}

func (m *GlobalConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *GlobalConfig) GetImagePullPolicy() string {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ""
}

func (m *GlobalConfig) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *GlobalConfig) GetIstioNamespace() string {
	if m != nil {
		return m.IstioNamespace
	}
	return ""
}

func (m *GlobalConfig) GetLogAsJson() *types.BoolValue {
	if m != nil {
		return m.LogAsJson
	}
	return nil
}

func (m *GlobalConfig) GetLogging() *GlobalLoggingConfig {
	if m != nil {
		return m.Logging
	}
	return nil
}

func (m *GlobalConfig) GetMeshID() string {
	if m != nil {
		return m.MeshID
	}
	return ""
}

func (m *GlobalConfig) GetMeshNetworks() *types.Struct {
	if m != nil {
		return m.MeshNetworks
	}
	return nil
}

func (m *GlobalConfig) GetMultiCluster() *MultiClusterConfig {
	if m != nil {
		return m.MultiCluster
	}
	return nil
}

func (m *GlobalConfig) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *GlobalConfig) GetPodDNSSearchNamespaces() []string {
	if m != nil {
		return m.PodDNSSearchNamespaces
	}
	return nil
}

func (m *GlobalConfig) GetOmitSidecarInjectorConfigMap() *types.BoolValue {
	if m != nil {
		return m.OmitSidecarInjectorConfigMap
	}
	return nil
}

func (m *GlobalConfig) GetOneNamespace() *types.BoolValue {
	if m != nil {
		return m.OneNamespace
	}
	return nil
}

func (m *GlobalConfig) GetOperatorManageWebhooks() *types.BoolValue {
	if m != nil {
		return m.OperatorManageWebhooks
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalConfig) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *GlobalConfig) GetProxy() *ProxyConfig {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *GlobalConfig) GetProxyInit() *ProxyInitConfig {
	if m != nil {
		return m.ProxyInit
	}
	return nil
}

func (m *GlobalConfig) GetSds() *SDSConfig {
	if m != nil {
		return m.Sds
	}
	return nil
}

func (m *GlobalConfig) GetTag() *types.Value {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *GlobalConfig) GetTracer() *TracerConfig {
	if m != nil {
		return m.Tracer
	}
	return nil
}

func (m *GlobalConfig) GetUseMCP() *types.BoolValue {
	if m != nil {
		return m.UseMCP
	}
	return nil
}

func (m *GlobalConfig) GetRemotePilotAddress() string {
	if m != nil {
		return m.RemotePilotAddress
	}
	return ""
}

func (m *GlobalConfig) GetIstiod() *IstiodConfig {
	if m != nil {
		return m.Istiod
	}
	return nil
}

func (m *GlobalConfig) GetPilotCertProvider() string {
	if m != nil {
		return m.PilotCertProvider
	}
	return ""
}

func (m *GlobalConfig) GetJwtPolicy() string {
	if m != nil {
		return m.JwtPolicy
	}
	return ""
}

func (m *GlobalConfig) GetSts() *STSConfig {
	if m != nil {
		return m.Sts
	}
	return nil
}

func (m *GlobalConfig) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *GlobalConfig) GetMountMtlsCerts() *types.BoolValue {
	if m != nil {
		return m.MountMtlsCerts
	}
	return nil
}

func (m *GlobalConfig) GetCaAddress() string {
	if m != nil {
		return m.CaAddress
	}
	return ""
}

func (m *GlobalConfig) GetExternalIstiod() *types.BoolValue {
	if m != nil {
		return m.ExternalIstiod
	}
	return nil
}

func (m *GlobalConfig) GetConfigCluster() *types.BoolValue {
	if m != nil {
		return m.ConfigCluster
	}
	return nil
}

func (m *GlobalConfig) GetCaName() string {
	if m != nil {
		return m.CaName
	}
	return ""
}

// Configuration for Security Token Service (STS) server.
//
// See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16
type STSConfig struct {
	ServicePort          uint32   `protobuf:"varint,1,opt,name=servicePort,proto3" json:"servicePort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *STSConfig) Reset()         { *m = STSConfig{} }
func (m *STSConfig) String() string { return proto.CompactTextString(m) }
func (*STSConfig) ProtoMessage()    {}
func (*STSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{13}
}
func (m *STSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *STSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_STSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *STSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_STSConfig.Merge(m, src)
}
func (m *STSConfig) XXX_Size() int {
	return m.Size()
}
func (m *STSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_STSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_STSConfig proto.InternalMessageInfo

func (m *STSConfig) GetServicePort() uint32 {
	if m != nil {
		return m.ServicePort
	}
	return 0
}

type IstiodConfig struct {
	// If enabled, istiod will perform config analysis
	EnableAnalysis       *types.BoolValue `protobuf:"bytes,2,opt,name=enableAnalysis,proto3" json:"enableAnalysis,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IstiodConfig) Reset()         { *m = IstiodConfig{} }
func (m *IstiodConfig) String() string { return proto.CompactTextString(m) }
func (*IstiodConfig) ProtoMessage()    {}
func (*IstiodConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{14}
}
func (m *IstiodConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstiodConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstiodConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstiodConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstiodConfig.Merge(m, src)
}
func (m *IstiodConfig) XXX_Size() int {
	return m.Size()
}
func (m *IstiodConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IstiodConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IstiodConfig proto.InternalMessageInfo

func (m *IstiodConfig) GetEnableAnalysis() *types.BoolValue {
	if m != nil {
		return m.EnableAnalysis
	}
	return nil
}

// GlobalLoggingConfig specifies the global logging level settings for the Istio control plane components.
type GlobalLoggingConfig struct {
	// Comma-separated minimum per-scope logging level of messages to output, in the form of <scope>:<level>,<scope>:<level>
	// The control plane has different scopes depending on component, but can configure default log level across all components
	// If empty, default scope and level will be used as configured in code
	Level                string   `protobuf:"bytes,1,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalLoggingConfig) Reset()         { *m = GlobalLoggingConfig{} }
func (m *GlobalLoggingConfig) String() string { return proto.CompactTextString(m) }
func (*GlobalLoggingConfig) ProtoMessage()    {}
func (*GlobalLoggingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{15}
}
func (m *GlobalLoggingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalLoggingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalLoggingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalLoggingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalLoggingConfig.Merge(m, src)
}
func (m *GlobalLoggingConfig) XXX_Size() int {
	return m.Size()
}
func (m *GlobalLoggingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalLoggingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalLoggingConfig proto.InternalMessageInfo

func (m *GlobalLoggingConfig) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

// Configuration for an ingress gateway.
type IngressGatewayConfig struct {
	// Controls whether auto scaling with a HorizontalPodAutoscaler is enabled.
	AutoscaleEnabled *types.BoolValue `protobuf:"bytes,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	// maxReplicas setting for HorizontalPodAutoscaler.
	AutoscaleMax uint32 `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	// minReplicas setting for HorizontalPodAutoscaler.
	AutoscaleMin uint32 `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	// K8s utilization setting for HorizontalPodAutoscaler target.
	//
	// See https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	Cpu           *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"` // Deprecated: Do not use.
	CustomService *types.BoolValue            `protobuf:"bytes,6,opt,name=customService,proto3" json:"customService,omitempty"`
	// Controls whether an ingress gateway is enabled.
	Enabled *types.BoolValue `protobuf:"bytes,10,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Environment variables passed to the proxy container.
	Env                      *types.Struct     `protobuf:"bytes,11,opt,name=env,proto3" json:"env,omitempty"`
	Labels                   map[string]string `protobuf:"bytes,15,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LoadBalancerIP           string            `protobuf:"bytes,16,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	LoadBalancerSourceRanges []string          `protobuf:"bytes,17,rep,name=loadBalancerSourceRanges,proto3" json:"loadBalancerSourceRanges,omitempty"`
	Name                     string            `protobuf:"bytes,44,opt,name=name,proto3" json:"name,omitempty"`
	// K8s node selector.
	//
	// See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector *types.Struct `protobuf:"bytes,19,opt,name=nodeSelector,proto3" json:"nodeSelector,omitempty"` // Deprecated: Do not use.
	// K8s annotations for pods.
	//
	// See: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations *types.Struct `protobuf:"bytes,20,opt,name=podAnnotations,proto3" json:"podAnnotations,omitempty"` // Deprecated: Do not use.
	// See EgressGatewayConfig.
	PodAntiAffinityLabelSelector []*types.Struct `protobuf:"bytes,21,rep,name=podAntiAffinityLabelSelector,proto3" json:"podAntiAffinityLabelSelector,omitempty"` // Deprecated: Do not use.
	// See EgressGatewayConfig.
	PodAntiAffinityTermLabelSelector []*types.Struct `protobuf:"bytes,22,rep,name=podAntiAffinityTermLabelSelector,proto3" json:"podAntiAffinityTermLabelSelector,omitempty"` // Deprecated: Do not use.
	// Port Configuration for the ingress gateway.
	Ports []*PortsConfig `protobuf:"bytes,23,rep,name=ports,proto3" json:"ports,omitempty"`
	// Number of replicas for the ingress gateway Deployment.
	ReplicaCount uint32 `protobuf:"varint,24,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"` // Deprecated: Do not use.
	// K8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *types.Struct `protobuf:"bytes,25,opt,name=resources,proto3" json:"resources,omitempty"` // Deprecated: Do not use.
	// Config for secret volume mounts.
	SecretVolumes []*SecretVolume `protobuf:"bytes,27,rep,name=secretVolumes,proto3" json:"secretVolumes,omitempty"`
	// Annotations to add to the egress gateway service.
	ServiceAnnotations *types.Struct `protobuf:"bytes,28,opt,name=serviceAnnotations,proto3" json:"serviceAnnotations,omitempty"`
	// Service type.
	//
	// See https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type string `protobuf:"bytes,29,opt,name=type,proto3" json:"type,omitempty"`
	// Enables cross-cluster access using SNI matching.
	Zvpn *IngressGatewayZvpnConfig `protobuf:"bytes,30,opt,name=zvpn,proto3" json:"zvpn,omitempty"`
	// K8s rolling update strategy
	RollingMaxSurge *IntOrString `protobuf:"bytes,31,opt,name=rollingMaxSurge,proto3" json:"rollingMaxSurge,omitempty"` // Deprecated: Do not use.
	// K8s rolling update strategy
	RollingMaxUnavailable *IntOrString     `protobuf:"bytes,32,opt,name=rollingMaxUnavailable,proto3" json:"rollingMaxUnavailable,omitempty"` // Deprecated: Do not use.
	ExternalTrafficPolicy string           `protobuf:"bytes,34,opt,name=externalTrafficPolicy,proto3" json:"externalTrafficPolicy,omitempty"`
	Tolerations           []*types.Struct  `protobuf:"bytes,35,rep,name=tolerations,proto3" json:"tolerations,omitempty"` // Deprecated: Do not use.
	IngressPorts          []*types.Struct  `protobuf:"bytes,36,rep,name=ingressPorts,proto3" json:"ingressPorts,omitempty"`
	AdditionalContainers  []*types.Struct  `protobuf:"bytes,37,rep,name=additionalContainers,proto3" json:"additionalContainers,omitempty"`
	ConfigVolumes         []*types.Struct  `protobuf:"bytes,38,rep,name=configVolumes,proto3" json:"configVolumes,omitempty"`
	RunAsRoot             *types.BoolValue `protobuf:"bytes,45,opt,name=runAsRoot,proto3" json:"runAsRoot,omitempty"`
	// The injection template to use for the gateway. If not set, no injection will be performed.
	InjectionTemplate    string          `protobuf:"bytes,46,opt,name=injectionTemplate,proto3" json:"injectionTemplate,omitempty"`
	ServiceAccount       *ServiceAccount `protobuf:"bytes,47,opt,name=serviceAccount,proto3" json:"serviceAccount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *IngressGatewayConfig) Reset()         { *m = IngressGatewayConfig{} }
func (m *IngressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayConfig) ProtoMessage()    {}
func (*IngressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{16}
}
func (m *IngressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayConfig.Merge(m, src)
}
func (m *IngressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayConfig proto.InternalMessageInfo

func (m *IngressGatewayConfig) GetAutoscaleEnabled() *types.BoolValue {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return nil
}

func (m *IngressGatewayConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *IngressGatewayConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *IngressGatewayConfig) GetCustomService() *types.BoolValue {
	if m != nil {
		return m.CustomService
	}
	return nil
}

func (m *IngressGatewayConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *IngressGatewayConfig) GetEnv() *types.Struct {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *IngressGatewayConfig) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *IngressGatewayConfig) GetLoadBalancerIP() string {
	if m != nil {
		return m.LoadBalancerIP
	}
	return ""
}

func (m *IngressGatewayConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *IngressGatewayConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetNodeSelector() *types.Struct {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetPodAnnotations() *types.Struct {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetPodAntiAffinityLabelSelector() []*types.Struct {
	if m != nil {
		return m.PodAntiAffinityLabelSelector
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetPodAntiAffinityTermLabelSelector() []*types.Struct {
	if m != nil {
		return m.PodAntiAffinityTermLabelSelector
	}
	return nil
}

func (m *IngressGatewayConfig) GetPorts() []*PortsConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetResources() *types.Struct {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *IngressGatewayConfig) GetSecretVolumes() []*SecretVolume {
	if m != nil {
		return m.SecretVolumes
	}
	return nil
}

func (m *IngressGatewayConfig) GetServiceAnnotations() *types.Struct {
	if m != nil {
		return m.ServiceAnnotations
	}
	return nil
}

func (m *IngressGatewayConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *IngressGatewayConfig) GetZvpn() *IngressGatewayZvpnConfig {
	if m != nil {
		return m.Zvpn
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetRollingMaxSurge() *IntOrString {
	if m != nil {
		return m.RollingMaxSurge
	}
	return nil
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetRollingMaxUnavailable() *IntOrString {
	if m != nil {
		return m.RollingMaxUnavailable
	}
	return nil
}

func (m *IngressGatewayConfig) GetExternalTrafficPolicy() string {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return ""
}

// Deprecated: Do not use.
func (m *IngressGatewayConfig) GetTolerations() []*types.Struct {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *IngressGatewayConfig) GetIngressPorts() []*types.Struct {
	if m != nil {
		return m.IngressPorts
	}
	return nil
}

func (m *IngressGatewayConfig) GetAdditionalContainers() []*types.Struct {
	if m != nil {
		return m.AdditionalContainers
	}
	return nil
}

func (m *IngressGatewayConfig) GetConfigVolumes() []*types.Struct {
	if m != nil {
		return m.ConfigVolumes
	}
	return nil
}

func (m *IngressGatewayConfig) GetRunAsRoot() *types.BoolValue {
	if m != nil {
		return m.RunAsRoot
	}
	return nil
}

func (m *IngressGatewayConfig) GetInjectionTemplate() string {
	if m != nil {
		return m.InjectionTemplate
	}
	return ""
}

func (m *IngressGatewayConfig) GetServiceAccount() *ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

// IngressGatewayZvpnConfig enables cross-cluster access using SNI matching.
type IngressGatewayZvpnConfig struct {
	// Controls whether ZeroVPN is enabled.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Suffix               string           `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IngressGatewayZvpnConfig) Reset()         { *m = IngressGatewayZvpnConfig{} }
func (m *IngressGatewayZvpnConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayZvpnConfig) ProtoMessage()    {}
func (*IngressGatewayZvpnConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{17}
}
func (m *IngressGatewayZvpnConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayZvpnConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayZvpnConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayZvpnConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayZvpnConfig.Merge(m, src)
}
func (m *IngressGatewayZvpnConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayZvpnConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayZvpnConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayZvpnConfig proto.InternalMessageInfo

func (m *IngressGatewayZvpnConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *IngressGatewayZvpnConfig) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

// MDPConfig specifies the Managed Data Plane config. ASM ONLY.
type MDPConfig struct {
	// Hub for MDP controller image.
	Hub string `protobuf:"bytes,1,opt,name=hub,proto3" json:"hub,omitempty"`
	// Tag for MDP controller image.
	Tag string `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	// Namespace that Istio is installed into.
	IstioNamespace string `protobuf:"bytes,3,opt,name=istioNamespace,proto3" json:"istioNamespace,omitempty"`
	// Namespace for MDP config.
	MdpNamespace string `protobuf:"bytes,4,opt,name=mdpNamespace,proto3" json:"mdpNamespace,omitempty"`
	// K8s resources for MDP controller.
	Resources *Resources `protobuf:"bytes,5,opt,name=resources,proto3" json:"resources,omitempty"`
	// Whether MDP is enabled.
	Enabled              *types.BoolValue `protobuf:"bytes,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MDPConfig) Reset()         { *m = MDPConfig{} }
func (m *MDPConfig) String() string { return proto.CompactTextString(m) }
func (*MDPConfig) ProtoMessage()    {}
func (*MDPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{18}
}
func (m *MDPConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MDPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MDPConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MDPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MDPConfig.Merge(m, src)
}
func (m *MDPConfig) XXX_Size() int {
	return m.Size()
}
func (m *MDPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MDPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MDPConfig proto.InternalMessageInfo

func (m *MDPConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *MDPConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *MDPConfig) GetIstioNamespace() string {
	if m != nil {
		return m.IstioNamespace
	}
	return ""
}

func (m *MDPConfig) GetMdpNamespace() string {
	if m != nil {
		return m.MdpNamespace
	}
	return ""
}

func (m *MDPConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *MDPConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

// MultiClusterConfig specifies the Configuration for Istio mesh across multiple clusters through the istio gateways.
type MultiClusterConfig struct {
	// Enables the connection between two kubernetes clusters via their respective ingressgateway services.
	// Use if the pods in each cluster cannot directly talk to one another.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	ClusterName          string           `protobuf:"bytes,2,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	GlobalDomainSuffix   string           `protobuf:"bytes,3,opt,name=globalDomainSuffix,proto3" json:"globalDomainSuffix,omitempty"`
	IncludeEnvoyFilter   *types.BoolValue `protobuf:"bytes,4,opt,name=includeEnvoyFilter,proto3" json:"includeEnvoyFilter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MultiClusterConfig) Reset()         { *m = MultiClusterConfig{} }
func (m *MultiClusterConfig) String() string { return proto.CompactTextString(m) }
func (*MultiClusterConfig) ProtoMessage()    {}
func (*MultiClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{19}
}
func (m *MultiClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiClusterConfig.Merge(m, src)
}
func (m *MultiClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *MultiClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MultiClusterConfig proto.InternalMessageInfo

func (m *MultiClusterConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *MultiClusterConfig) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *MultiClusterConfig) GetGlobalDomainSuffix() string {
	if m != nil {
		return m.GlobalDomainSuffix
	}
	return ""
}

func (m *MultiClusterConfig) GetIncludeEnvoyFilter() *types.BoolValue {
	if m != nil {
		return m.IncludeEnvoyFilter
	}
	return nil
}

// OutboundTrafficPolicyConfig controls the default behavior of the sidecar for handling outbound traffic from the application.
type OutboundTrafficPolicyConfig struct {
	Mode                 OutboundTrafficPolicyConfig_Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=v1alpha1.OutboundTrafficPolicyConfig_Mode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *OutboundTrafficPolicyConfig) Reset()         { *m = OutboundTrafficPolicyConfig{} }
func (m *OutboundTrafficPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*OutboundTrafficPolicyConfig) ProtoMessage()    {}
func (*OutboundTrafficPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{20}
}
func (m *OutboundTrafficPolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutboundTrafficPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutboundTrafficPolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutboundTrafficPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutboundTrafficPolicyConfig.Merge(m, src)
}
func (m *OutboundTrafficPolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *OutboundTrafficPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OutboundTrafficPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OutboundTrafficPolicyConfig proto.InternalMessageInfo

func (m *OutboundTrafficPolicyConfig) GetMode() OutboundTrafficPolicyConfig_Mode {
	if m != nil {
		return m.Mode
	}
	return OutboundTrafficPolicyConfig_ALLOW_ANY
}

// Configuration for Pilot.
type PilotConfig struct {
	// Controls whether Pilot is enabled.
	Enabled *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Controls whether a HorizontalPodAutoscaler is installed for Pilot.
	AutoscaleEnabled *types.BoolValue `protobuf:"bytes,2,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	// Minimum number of replicas in the HorizontalPodAutoscaler for Pilot.
	AutoscaleMin uint32 `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	// Maximum number of replicas in the HorizontalPodAutoscaler for Pilot.
	AutoscaleMax uint32 `protobuf:"varint,4,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	// Number of replicas in the Pilot Deployment.
	ReplicaCount uint32 `protobuf:"varint,5,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"` // Deprecated: Do not use.
	// Image name used for Pilot.
	//
	// This can be set either to image name if hub is also set, or can be set to the full hub:name string.
	//
	// Examples: custom-pilot, docker.io/someuser:custom-pilot
	Image string `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	// Trace sampling fraction.
	//
	// Used to set the fraction of time that traces are sampled. Higher values are more accurate but add CPU overhead.
	//
	// Allowed values: 0.0 to 1.0
	TraceSampling float64 `protobuf:"fixed64,8,opt,name=traceSampling,proto3" json:"traceSampling,omitempty"`
	// K8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *Resources `protobuf:"bytes,9,opt,name=resources,proto3" json:"resources,omitempty"` // Deprecated: Do not use.
	// Namespace that the configuration management feature is installed into, if different from Pilot namespace.
	ConfigNamespace string `protobuf:"bytes,10,opt,name=configNamespace,proto3" json:"configNamespace,omitempty"`
	// Target CPU utilization used in HorizontalPodAutoscaler.
	//
	// See https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	Cpu *CPUTargetUtilizationConfig `protobuf:"bytes,11,opt,name=cpu,proto3" json:"cpu,omitempty"` // Deprecated: Do not use.
	// K8s node selector.
	//
	// See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector *types.Struct `protobuf:"bytes,12,opt,name=nodeSelector,proto3" json:"nodeSelector,omitempty"` // Deprecated: Do not use.
	// Maximum duration that a sidecar can be connected to a pilot.
	//
	// This setting balances out load across pilot instances, but adds some resource overhead.
	//
	// Examples: 300s, 30m, 1h
	KeepaliveMaxServerConnectionAge *types.Duration `protobuf:"bytes,13,opt,name=keepaliveMaxServerConnectionAge,proto3" json:"keepaliveMaxServerConnectionAge,omitempty"`
	// Labels that are added to Pilot deployment and pods.
	//
	// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
	DeploymentLabels *types.Struct `protobuf:"bytes,14,opt,name=deploymentLabels,proto3" json:"deploymentLabels,omitempty"`
	PodLabels        *types.Struct `protobuf:"bytes,36,opt,name=podLabels,proto3" json:"podLabels,omitempty"`
	// Configuration settings passed to Pilot as a ConfigMap.
	//
	// This controls whether the mesh config map, generated from values.yaml is generated.
	// If false, pilot wil use default values or user-supplied values, in that order of preference.
	ConfigMap *types.BoolValue `protobuf:"bytes,18,opt,name=configMap,proto3" json:"configMap,omitempty"`
	// Controls whether Pilot is configured through the Mesh Control Protocol (MCP).
	//
	// If set to true, Pilot requires an MCP server (like Galley) to be installed.
	UseMCP *types.BoolValue `protobuf:"bytes,20,opt,name=useMCP,proto3" json:"useMCP,omitempty"`
	// Environment variables passed to the Pilot container.
	//
	// Examples:
	// env:
	//   ENV_VAR_1: value1
	//   ENV_VAR_2: value2
	Env *types.Struct `protobuf:"bytes,21,opt,name=env,proto3" json:"env,omitempty"`
	// K8s rolling update strategy
	RollingMaxSurge *IntOrString `protobuf:"bytes,24,opt,name=rollingMaxSurge,proto3" json:"rollingMaxSurge,omitempty"` // Deprecated: Do not use.
	// K8s rolling update strategy
	RollingMaxUnavailable *IntOrString `protobuf:"bytes,25,opt,name=rollingMaxUnavailable,proto3" json:"rollingMaxUnavailable,omitempty"` // Deprecated: Do not use.
	//
	Tolerations []*types.Struct `protobuf:"bytes,26,rep,name=tolerations,proto3" json:"tolerations,omitempty"` // Deprecated: Do not use.
	// if protocol sniffing is enabled for outbound
	EnableProtocolSniffingForOutbound *types.BoolValue `protobuf:"bytes,28,opt,name=enableProtocolSniffingForOutbound,proto3" json:"enableProtocolSniffingForOutbound,omitempty"`
	// if protocol sniffing is enabled for inbound
	EnableProtocolSniffingForInbound *types.BoolValue `protobuf:"bytes,29,opt,name=enableProtocolSniffingForInbound,proto3" json:"enableProtocolSniffingForInbound,omitempty"`
	// K8s annotations for pods.
	//
	// See: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations     *types.Struct `protobuf:"bytes,30,opt,name=podAnnotations,proto3" json:"podAnnotations,omitempty"` // Deprecated: Do not use.
	ServiceAnnotations *types.Struct `protobuf:"bytes,37,opt,name=serviceAnnotations,proto3" json:"serviceAnnotations,omitempty"`
	// ConfigSource describes a source of configuration data for networking
	// rules, and other Istio configuration artifacts. Multiple data sources
	// can be configured for a single control plane.
	ConfigSource            *PilotConfigSource `protobuf:"bytes,31,opt,name=configSource,proto3" json:"configSource,omitempty"`
	JwksResolverExtraRootCA string             `protobuf:"bytes,32,opt,name=jwksResolverExtraRootCA,proto3" json:"jwksResolverExtraRootCA,omitempty"`
	Plugins                 []string           `protobuf:"bytes,33,rep,name=plugins,proto3" json:"plugins,omitempty"`
	Hub                     string             `protobuf:"bytes,34,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag                     *types.Value       `protobuf:"bytes,35,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}           `json:"-"`
	XXX_unrecognized        []byte             `json:"-"`
	XXX_sizecache           int32              `json:"-"`
}

func (m *PilotConfig) Reset()         { *m = PilotConfig{} }
func (m *PilotConfig) String() string { return proto.CompactTextString(m) }
func (*PilotConfig) ProtoMessage()    {}
func (*PilotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{21}
}
func (m *PilotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotConfig.Merge(m, src)
}
func (m *PilotConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotConfig proto.InternalMessageInfo

func (m *PilotConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *PilotConfig) GetAutoscaleEnabled() *types.BoolValue {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return nil
}

func (m *PilotConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *PilotConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

// Deprecated: Do not use.
func (m *PilotConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *PilotConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PilotConfig) GetTraceSampling() float64 {
	if m != nil {
		return m.TraceSampling
	}
	return 0
}

// Deprecated: Do not use.
func (m *PilotConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PilotConfig) GetConfigNamespace() string {
	if m != nil {
		return m.ConfigNamespace
	}
	return ""
}

// Deprecated: Do not use.
func (m *PilotConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

// Deprecated: Do not use.
func (m *PilotConfig) GetNodeSelector() *types.Struct {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *PilotConfig) GetKeepaliveMaxServerConnectionAge() *types.Duration {
	if m != nil {
		return m.KeepaliveMaxServerConnectionAge
	}
	return nil
}

func (m *PilotConfig) GetDeploymentLabels() *types.Struct {
	if m != nil {
		return m.DeploymentLabels
	}
	return nil
}

func (m *PilotConfig) GetPodLabels() *types.Struct {
	if m != nil {
		return m.PodLabels
	}
	return nil
}

func (m *PilotConfig) GetConfigMap() *types.BoolValue {
	if m != nil {
		return m.ConfigMap
	}
	return nil
}

func (m *PilotConfig) GetUseMCP() *types.BoolValue {
	if m != nil {
		return m.UseMCP
	}
	return nil
}

func (m *PilotConfig) GetEnv() *types.Struct {
	if m != nil {
		return m.Env
	}
	return nil
}

// Deprecated: Do not use.
func (m *PilotConfig) GetRollingMaxSurge() *IntOrString {
	if m != nil {
		return m.RollingMaxSurge
	}
	return nil
}

// Deprecated: Do not use.
func (m *PilotConfig) GetRollingMaxUnavailable() *IntOrString {
	if m != nil {
		return m.RollingMaxUnavailable
	}
	return nil
}

// Deprecated: Do not use.
func (m *PilotConfig) GetTolerations() []*types.Struct {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *PilotConfig) GetEnableProtocolSniffingForOutbound() *types.BoolValue {
	if m != nil {
		return m.EnableProtocolSniffingForOutbound
	}
	return nil
}

func (m *PilotConfig) GetEnableProtocolSniffingForInbound() *types.BoolValue {
	if m != nil {
		return m.EnableProtocolSniffingForInbound
	}
	return nil
}

// Deprecated: Do not use.
func (m *PilotConfig) GetPodAnnotations() *types.Struct {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *PilotConfig) GetServiceAnnotations() *types.Struct {
	if m != nil {
		return m.ServiceAnnotations
	}
	return nil
}

func (m *PilotConfig) GetConfigSource() *PilotConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return nil
}

func (m *PilotConfig) GetJwksResolverExtraRootCA() string {
	if m != nil {
		return m.JwksResolverExtraRootCA
	}
	return ""
}

func (m *PilotConfig) GetPlugins() []string {
	if m != nil {
		return m.Plugins
	}
	return nil
}

func (m *PilotConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *PilotConfig) GetTag() *types.Value {
	if m != nil {
		return m.Tag
	}
	return nil
}

type HSMConfig struct {
	// Controls whether HSM is configured.
	Enabled *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// HSM KEK ID.
	HsmKEKID string `protobuf:"bytes,2,opt,name=hsmKEKID,proto3" json:"hsmKEKID,omitempty"`
	// Image of the HSM plugin.
	HsmPluginImage string `protobuf:"bytes,3,opt,name=hsmPluginImage,proto3" json:"hsmPluginImage,omitempty"`
	// The HSM slot Label.
	HsmSlotLabel string `protobuf:"bytes,4,opt,name=hsmSlotLabel,proto3" json:"hsmSlotLabel,omitempty"`
	// Image of the Vault client.
	VaultClientImage string `protobuf:"bytes,5,opt,name=vaultClientImage,proto3" json:"vaultClientImage,omitempty"`
	// The address of the Vault server.
	VaultAddr string `protobuf:"bytes,6,opt,name=vaultAddr,proto3" json:"vaultAddr,omitempty"`
	// The path of the Vault authentication path.
	VaultAuthPath string `protobuf:"bytes,7,opt,name=vaultAuthPath,proto3" json:"vaultAuthPath,omitempty"`
	// The role to authenticate to Vault.
	VaultAuthRole string `protobuf:"bytes,8,opt,name=vaultAuthRole,proto3" json:"vaultAuthRole,omitempty"`
	// The path to the JWT token to authenticate to Vault.
	VaultAuthJwtPath string `protobuf:"bytes,9,opt,name=vaultAuthJwtPath,proto3" json:"vaultAuthJwtPath,omitempty"`
	// The path to access the secret on Vault.
	VaultSecretPath      string   `protobuf:"bytes,10,opt,name=vaultSecretPath,proto3" json:"vaultSecretPath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSMConfig) Reset()         { *m = HSMConfig{} }
func (m *HSMConfig) String() string { return proto.CompactTextString(m) }
func (*HSMConfig) ProtoMessage()    {}
func (*HSMConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{22}
}
func (m *HSMConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSMConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSMConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSMConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSMConfig.Merge(m, src)
}
func (m *HSMConfig) XXX_Size() int {
	return m.Size()
}
func (m *HSMConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HSMConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HSMConfig proto.InternalMessageInfo

func (m *HSMConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *HSMConfig) GetHsmKEKID() string {
	if m != nil {
		return m.HsmKEKID
	}
	return ""
}

func (m *HSMConfig) GetHsmPluginImage() string {
	if m != nil {
		return m.HsmPluginImage
	}
	return ""
}

func (m *HSMConfig) GetHsmSlotLabel() string {
	if m != nil {
		return m.HsmSlotLabel
	}
	return ""
}

func (m *HSMConfig) GetVaultClientImage() string {
	if m != nil {
		return m.VaultClientImage
	}
	return ""
}

func (m *HSMConfig) GetVaultAddr() string {
	if m != nil {
		return m.VaultAddr
	}
	return ""
}

func (m *HSMConfig) GetVaultAuthPath() string {
	if m != nil {
		return m.VaultAuthPath
	}
	return ""
}

func (m *HSMConfig) GetVaultAuthRole() string {
	if m != nil {
		return m.VaultAuthRole
	}
	return ""
}

func (m *HSMConfig) GetVaultAuthJwtPath() string {
	if m != nil {
		return m.VaultAuthJwtPath
	}
	return ""
}

func (m *HSMConfig) GetVaultSecretPath() string {
	if m != nil {
		return m.VaultSecretPath
	}
	return ""
}

// Controls legacy k8s ingress. Only one pilot profile should enable ingress support.
type PilotIngressConfig struct {
	// Sets the type ingress service for Pilot.
	//
	// If empty, node-port is assumed.
	//
	// Allowed values: node-port, istio-ingressgateway, ingress
	IngressService        string                `protobuf:"bytes,1,opt,name=ingressService,proto3" json:"ingressService,omitempty"`
	IngressControllerMode IngressControllerMode `protobuf:"varint,2,opt,name=ingressControllerMode,proto3,enum=v1alpha1.IngressControllerMode" json:"ingressControllerMode,omitempty"`
	// If mode is STRICT, this value must be set on "kubernetes.io/ingress.class" annotation to activate.
	IngressClass         string   `protobuf:"bytes,3,opt,name=ingressClass,proto3" json:"ingressClass,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PilotIngressConfig) Reset()         { *m = PilotIngressConfig{} }
func (m *PilotIngressConfig) String() string { return proto.CompactTextString(m) }
func (*PilotIngressConfig) ProtoMessage()    {}
func (*PilotIngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{23}
}
func (m *PilotIngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotIngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotIngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotIngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotIngressConfig.Merge(m, src)
}
func (m *PilotIngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotIngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotIngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotIngressConfig proto.InternalMessageInfo

func (m *PilotIngressConfig) GetIngressService() string {
	if m != nil {
		return m.IngressService
	}
	return ""
}

func (m *PilotIngressConfig) GetIngressControllerMode() IngressControllerMode {
	if m != nil {
		return m.IngressControllerMode
	}
	return IngressControllerMode_UNSPECIFIED
}

func (m *PilotIngressConfig) GetIngressClass() string {
	if m != nil {
		return m.IngressClass
	}
	return ""
}

// Controls whether Istio policy is applied to Pilot.
type PilotPolicyConfig struct {
	// Controls whether Istio policy is applied to Pilot.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PilotPolicyConfig) Reset()         { *m = PilotPolicyConfig{} }
func (m *PilotPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*PilotPolicyConfig) ProtoMessage()    {}
func (*PilotPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{24}
}
func (m *PilotPolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotPolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotPolicyConfig.Merge(m, src)
}
func (m *PilotPolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotPolicyConfig proto.InternalMessageInfo

func (m *PilotPolicyConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

// Controls telemetry configuration
type TelemetryConfig struct {
	// Controls whether telemetry is exported for Pilot.
	Enabled *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Use telemetry v2.
	V2                   *TelemetryV2Config `protobuf:"bytes,3,opt,name=v2,proto3" json:"v2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TelemetryConfig) Reset()         { *m = TelemetryConfig{} }
func (m *TelemetryConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig) ProtoMessage()    {}
func (*TelemetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{25}
}
func (m *TelemetryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig.Merge(m, src)
}
func (m *TelemetryConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig proto.InternalMessageInfo

func (m *TelemetryConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TelemetryConfig) GetV2() *TelemetryV2Config {
	if m != nil {
		return m.V2
	}
	return nil
}

// Controls whether pilot will configure telemetry v2.
type TelemetryV2Config struct {
	// Controls whether pilot will configure telemetry v2.
	Enabled              *types.BoolValue                        `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MetadataExchange     *TelemetryV2MetadataExchangeConfig      `protobuf:"bytes,4,opt,name=metadata_exchange,json=metadataExchange,proto3" json:"metadata_exchange,omitempty"`
	Prometheus           *TelemetryV2PrometheusConfig            `protobuf:"bytes,2,opt,name=prometheus,proto3" json:"prometheus,omitempty"`
	Stackdriver          *TelemetryV2StackDriverConfig           `protobuf:"bytes,3,opt,name=stackdriver,proto3" json:"stackdriver,omitempty"`
	AccessLogPolicy      *TelemetryV2AccessLogPolicyFilterConfig `protobuf:"bytes,5,opt,name=access_log_policy,json=accessLogPolicy,proto3" json:"access_log_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *TelemetryV2Config) Reset()         { *m = TelemetryV2Config{} }
func (m *TelemetryV2Config) String() string { return proto.CompactTextString(m) }
func (*TelemetryV2Config) ProtoMessage()    {}
func (*TelemetryV2Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{26}
}
func (m *TelemetryV2Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2Config.Merge(m, src)
}
func (m *TelemetryV2Config) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2Config) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2Config.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2Config proto.InternalMessageInfo

func (m *TelemetryV2Config) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TelemetryV2Config) GetMetadataExchange() *TelemetryV2MetadataExchangeConfig {
	if m != nil {
		return m.MetadataExchange
	}
	return nil
}

func (m *TelemetryV2Config) GetPrometheus() *TelemetryV2PrometheusConfig {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

func (m *TelemetryV2Config) GetStackdriver() *TelemetryV2StackDriverConfig {
	if m != nil {
		return m.Stackdriver
	}
	return nil
}

func (m *TelemetryV2Config) GetAccessLogPolicy() *TelemetryV2AccessLogPolicyFilterConfig {
	if m != nil {
		return m.AccessLogPolicy
	}
	return nil
}

type TelemetryV2MetadataExchangeConfig struct {
	// Controls whether enabled WebAssembly runtime for metadata exchange filter.
	WasmEnabled          *types.BoolValue `protobuf:"bytes,2,opt,name=wasmEnabled,proto3" json:"wasmEnabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TelemetryV2MetadataExchangeConfig) Reset()         { *m = TelemetryV2MetadataExchangeConfig{} }
func (m *TelemetryV2MetadataExchangeConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryV2MetadataExchangeConfig) ProtoMessage()    {}
func (*TelemetryV2MetadataExchangeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{27}
}
func (m *TelemetryV2MetadataExchangeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2MetadataExchangeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2MetadataExchangeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2MetadataExchangeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2MetadataExchangeConfig.Merge(m, src)
}
func (m *TelemetryV2MetadataExchangeConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2MetadataExchangeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2MetadataExchangeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2MetadataExchangeConfig proto.InternalMessageInfo

func (m *TelemetryV2MetadataExchangeConfig) GetWasmEnabled() *types.BoolValue {
	if m != nil {
		return m.WasmEnabled
	}
	return nil
}

// Conrols telemetry v2 prometheus settings.
type TelemetryV2PrometheusConfig struct {
	// Controls whether stats envoyfilter would be enabled or not.
	Enabled *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Controls whether enabled WebAssembly runtime for stats filter.
	WasmEnabled *types.BoolValue `protobuf:"bytes,2,opt,name=wasmEnabled,proto3" json:"wasmEnabled,omitempty"`
	// Overrides default telemetry v2 filter configuration.
	ConfigOverride       *TelemetryV2PrometheusConfig_ConfigOverride `protobuf:"bytes,3,opt,name=config_override,json=configOverride,proto3" json:"config_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *TelemetryV2PrometheusConfig) Reset()         { *m = TelemetryV2PrometheusConfig{} }
func (m *TelemetryV2PrometheusConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryV2PrometheusConfig) ProtoMessage()    {}
func (*TelemetryV2PrometheusConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{28}
}
func (m *TelemetryV2PrometheusConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2PrometheusConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2PrometheusConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2PrometheusConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2PrometheusConfig.Merge(m, src)
}
func (m *TelemetryV2PrometheusConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2PrometheusConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2PrometheusConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2PrometheusConfig proto.InternalMessageInfo

func (m *TelemetryV2PrometheusConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TelemetryV2PrometheusConfig) GetWasmEnabled() *types.BoolValue {
	if m != nil {
		return m.WasmEnabled
	}
	return nil
}

func (m *TelemetryV2PrometheusConfig) GetConfigOverride() *TelemetryV2PrometheusConfig_ConfigOverride {
	if m != nil {
		return m.ConfigOverride
	}
	return nil
}

type TelemetryV2PrometheusConfig_ConfigOverride struct {
	// Overrides default gateway telemetry v2 configuration.
	Gateway *types.Struct `protobuf:"bytes,1,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Overrides default inbound sidecar telemetry v2 configuration.
	InboundSidecar *types.Struct `protobuf:"bytes,2,opt,name=inboundSidecar,proto3" json:"inboundSidecar,omitempty"`
	// Overrides default outbound sidecar telemetry v2 configuration.
	OutboundSidecar      *types.Struct `protobuf:"bytes,3,opt,name=outboundSidecar,proto3" json:"outboundSidecar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) Reset() {
	*m = TelemetryV2PrometheusConfig_ConfigOverride{}
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) String() string {
	return proto.CompactTextString(m)
}
func (*TelemetryV2PrometheusConfig_ConfigOverride) ProtoMessage() {}
func (*TelemetryV2PrometheusConfig_ConfigOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{28, 0}
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2PrometheusConfig_ConfigOverride.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2PrometheusConfig_ConfigOverride.Merge(m, src)
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2PrometheusConfig_ConfigOverride.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2PrometheusConfig_ConfigOverride proto.InternalMessageInfo

func (m *TelemetryV2PrometheusConfig_ConfigOverride) GetGateway() *types.Struct {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) GetInboundSidecar() *types.Struct {
	if m != nil {
		return m.InboundSidecar
	}
	return nil
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) GetOutboundSidecar() *types.Struct {
	if m != nil {
		return m.OutboundSidecar
	}
	return nil
}

// Conrols telemetry v2 stackdriver settings.
type TelemetryV2StackDriverConfig struct {
	Enabled               *types.BoolValue                           `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Logging               *types.BoolValue                           `protobuf:"bytes,2,opt,name=logging,proto3" json:"logging,omitempty"` // Deprecated: Do not use.
	Monitoring            *types.BoolValue                           `protobuf:"bytes,3,opt,name=monitoring,proto3" json:"monitoring,omitempty"`
	Topology              *types.BoolValue                           `protobuf:"bytes,4,opt,name=topology,proto3" json:"topology,omitempty"` // Deprecated: Do not use.
	DisableOutbound       *types.BoolValue                           `protobuf:"bytes,6,opt,name=disableOutbound,proto3" json:"disableOutbound,omitempty"`
	ConfigOverride        *types.Struct                              `protobuf:"bytes,5,opt,name=configOverride,proto3" json:"configOverride,omitempty"`
	OutboundAccessLogging TelemetryV2StackDriverConfig_AccessLogging `protobuf:"varint,7,opt,name=outboundAccessLogging,proto3,enum=v1alpha1.TelemetryV2StackDriverConfig_AccessLogging" json:"outboundAccessLogging,omitempty"`
	InboundAccessLogging  TelemetryV2StackDriverConfig_AccessLogging `protobuf:"varint,8,opt,name=inboundAccessLogging,proto3,enum=v1alpha1.TelemetryV2StackDriverConfig_AccessLogging" json:"inboundAccessLogging,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                   `json:"-"`
	XXX_unrecognized      []byte                                     `json:"-"`
	XXX_sizecache         int32                                      `json:"-"`
}

func (m *TelemetryV2StackDriverConfig) Reset()         { *m = TelemetryV2StackDriverConfig{} }
func (m *TelemetryV2StackDriverConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryV2StackDriverConfig) ProtoMessage()    {}
func (*TelemetryV2StackDriverConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{29}
}
func (m *TelemetryV2StackDriverConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2StackDriverConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2StackDriverConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2StackDriverConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2StackDriverConfig.Merge(m, src)
}
func (m *TelemetryV2StackDriverConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2StackDriverConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2StackDriverConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2StackDriverConfig proto.InternalMessageInfo

func (m *TelemetryV2StackDriverConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

// Deprecated: Do not use.
func (m *TelemetryV2StackDriverConfig) GetLogging() *types.BoolValue {
	if m != nil {
		return m.Logging
	}
	return nil
}

func (m *TelemetryV2StackDriverConfig) GetMonitoring() *types.BoolValue {
	if m != nil {
		return m.Monitoring
	}
	return nil
}

// Deprecated: Do not use.
func (m *TelemetryV2StackDriverConfig) GetTopology() *types.BoolValue {
	if m != nil {
		return m.Topology
	}
	return nil
}

func (m *TelemetryV2StackDriverConfig) GetDisableOutbound() *types.BoolValue {
	if m != nil {
		return m.DisableOutbound
	}
	return nil
}

func (m *TelemetryV2StackDriverConfig) GetConfigOverride() *types.Struct {
	if m != nil {
		return m.ConfigOverride
	}
	return nil
}

func (m *TelemetryV2StackDriverConfig) GetOutboundAccessLogging() TelemetryV2StackDriverConfig_AccessLogging {
	if m != nil {
		return m.OutboundAccessLogging
	}
	return TelemetryV2StackDriverConfig_NONE
}

func (m *TelemetryV2StackDriverConfig) GetInboundAccessLogging() TelemetryV2StackDriverConfig_AccessLogging {
	if m != nil {
		return m.InboundAccessLogging
	}
	return TelemetryV2StackDriverConfig_NONE
}

// Conrols telemetry v2 access log policy filter settings.
type TelemetryV2AccessLogPolicyFilterConfig struct {
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	LogWindowDuration    *types.Duration  `protobuf:"bytes,2,opt,name=logWindowDuration,proto3" json:"logWindowDuration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) Reset() {
	*m = TelemetryV2AccessLogPolicyFilterConfig{}
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryV2AccessLogPolicyFilterConfig) ProtoMessage()    {}
func (*TelemetryV2AccessLogPolicyFilterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{30}
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryV2AccessLogPolicyFilterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryV2AccessLogPolicyFilterConfig.Merge(m, src)
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryV2AccessLogPolicyFilterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryV2AccessLogPolicyFilterConfig proto.InternalMessageInfo

func (m *TelemetryV2AccessLogPolicyFilterConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) GetLogWindowDuration() *types.Duration {
	if m != nil {
		return m.LogWindowDuration
	}
	return nil
}

// PilotConfigSource describes information about a configuration store inside a
// mesh. A single control plane instance can interact with one or more data
// sources.
type PilotConfigSource struct {
	// Describes the source of configuration, if nothing is specified default is MCP.
	SubscribedResources  []string `protobuf:"bytes,1,rep,name=subscribedResources,proto3" json:"subscribedResources,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PilotConfigSource) Reset()         { *m = PilotConfigSource{} }
func (m *PilotConfigSource) String() string { return proto.CompactTextString(m) }
func (*PilotConfigSource) ProtoMessage()    {}
func (*PilotConfigSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{31}
}
func (m *PilotConfigSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotConfigSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotConfigSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotConfigSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotConfigSource.Merge(m, src)
}
func (m *PilotConfigSource) XXX_Size() int {
	return m.Size()
}
func (m *PilotConfigSource) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotConfigSource.DiscardUnknown(m)
}

var xxx_messageInfo_PilotConfigSource proto.InternalMessageInfo

func (m *PilotConfigSource) GetSubscribedResources() []string {
	if m != nil {
		return m.SubscribedResources
	}
	return nil
}

// Configuration for a port.
type PortsConfig struct {
	// Port name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Port number.
	Port int32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// NodePort number.
	NodePort int32 `protobuf:"varint,3,opt,name=nodePort,proto3" json:"nodePort,omitempty"`
	// Target port number.
	TargetPort int32 `protobuf:"varint,4,opt,name=targetPort,proto3" json:"targetPort,omitempty"`
	// Protocol name.
	Protocol             string   `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortsConfig) Reset()         { *m = PortsConfig{} }
func (m *PortsConfig) String() string { return proto.CompactTextString(m) }
func (*PortsConfig) ProtoMessage()    {}
func (*PortsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{32}
}
func (m *PortsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortsConfig.Merge(m, src)
}
func (m *PortsConfig) XXX_Size() int {
	return m.Size()
}
func (m *PortsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PortsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PortsConfig proto.InternalMessageInfo

func (m *PortsConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortsConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortsConfig) GetNodePort() int32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

func (m *PortsConfig) GetTargetPort() int32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

func (m *PortsConfig) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

// Configuration for Proxy.
type ProxyConfig struct {
	AutoInject string `protobuf:"bytes,4,opt,name=autoInject,proto3" json:"autoInject,omitempty"`
	// Domain for the cluster, default: "cluster.local".
	//
	// K8s allows this to be customized, see https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/
	ClusterDomain string `protobuf:"bytes,5,opt,name=clusterDomain,proto3" json:"clusterDomain,omitempty"`
	// Per Component log level for proxy, applies to gateways and sidecars.
	//
	// If a component level is not set, then the global "logLevel" will be used. If left empty, "misc:error" is used.
	ComponentLogLevel string `protobuf:"bytes,6,opt,name=componentLogLevel,proto3" json:"componentLogLevel,omitempty"`
	// Enables core dumps for newly injected sidecars.
	//
	// If set, newly injected sidecars will have core dumps enabled.
	EnableCoreDump *types.BoolValue `protobuf:"bytes,9,opt,name=enableCoreDump,proto3" json:"enableCoreDump,omitempty"`
	// Specifies the Istio ingress ports not to capture.
	ExcludeInboundPorts string `protobuf:"bytes,12,opt,name=excludeInboundPorts,proto3" json:"excludeInboundPorts,omitempty"`
	// Lists the excluded IP ranges of Istio egress traffic that the sidecar captures.
	ExcludeIPRanges string `protobuf:"bytes,13,opt,name=excludeIPRanges,proto3" json:"excludeIPRanges,omitempty"`
	// Image name or path for the proxy, default: "proxyv2".
	//
	// If registry or tag are not specified, global.hub and global.tag are used.
	//
	// Examples: my-proxy (uses global.hub/tag), docker.io/myrepo/my-proxy:v1.0.0
	Image string `protobuf:"bytes,14,opt,name=image,proto3" json:"image,omitempty"`
	// Lists the IP ranges of Istio egress traffic that the sidecar captures.
	//
	// Example: "172.30.0.0/16,172.20.0.0/16"
	// This would only capture egress traffic on those two IP Ranges, all other outbound traffic would # be allowed by the sidecar."
	IncludeIPRanges string `protobuf:"bytes,16,opt,name=includeIPRanges,proto3" json:"includeIPRanges,omitempty"`
	// Log level for proxy, applies to gateways and sidecars. If left empty, "warning" is used. Expected values are: trace\|debug\|info\|warning\|error\|critical\|off
	LogLevel string `protobuf:"bytes,18,opt,name=logLevel,proto3" json:"logLevel,omitempty"`
	// Enables privileged securityContext for the istio-proxy container.
	//
	// See https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
	Privileged *types.BoolValue `protobuf:"bytes,19,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Sets the initial delay for readiness probes in seconds.
	ReadinessInitialDelaySeconds uint32 `protobuf:"varint,20,opt,name=readinessInitialDelaySeconds,proto3" json:"readinessInitialDelaySeconds,omitempty"`
	// Sets the interval between readiness probes in seconds.
	ReadinessPeriodSeconds uint32 `protobuf:"varint,21,opt,name=readinessPeriodSeconds,proto3" json:"readinessPeriodSeconds,omitempty"`
	// Sets the number of successive failed probes before indicating readiness failure.
	ReadinessFailureThreshold uint32 `protobuf:"varint,22,opt,name=readinessFailureThreshold,proto3" json:"readinessFailureThreshold,omitempty"`
	// Default port used for the Pilot agent's health checks.
	StatusPort uint32 `protobuf:"varint,23,opt,name=statusPort,proto3" json:"statusPort,omitempty"`
	// K8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources            *Resources    `protobuf:"bytes,24,opt,name=resources,proto3" json:"resources,omitempty"` // Deprecated: Do not use.
	Tracer               Tracer        `protobuf:"varint,25,opt,name=tracer,proto3,enum=v1alpha1.Tracer" json:"tracer,omitempty"`
	ExcludeOutboundPorts string        `protobuf:"bytes,28,opt,name=excludeOutboundPorts,proto3" json:"excludeOutboundPorts,omitempty"`
	Lifecycle            *types.Struct `protobuf:"bytes,36,opt,name=lifecycle,proto3" json:"lifecycle,omitempty"`
	// Controls if sidecar is injected at the front of the container list and blocks the start of the other containers until the proxy is ready
	//
	// Deprecated: replaced by ProxyConfig setting which allows per-pod configuration of this behavior.
	HoldApplicationUntilProxyStarts *types.BoolValue `protobuf:"bytes,37,opt,name=holdApplicationUntilProxyStarts,proto3" json:"holdApplicationUntilProxyStarts,omitempty"` // Deprecated: Do not use.
	IncludeInboundPorts             string           `protobuf:"bytes,38,opt,name=includeInboundPorts,proto3" json:"includeInboundPorts,omitempty"`
	IncludeOutboundPorts            string           `protobuf:"bytes,39,opt,name=includeOutboundPorts,proto3" json:"includeOutboundPorts,omitempty"`
	XXX_NoUnkeyedLiteral            struct{}         `json:"-"`
	XXX_unrecognized                []byte           `json:"-"`
	XXX_sizecache                   int32            `json:"-"`
}

func (m *ProxyConfig) Reset()         { *m = ProxyConfig{} }
func (m *ProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyConfig) ProtoMessage()    {}
func (*ProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{33}
}
func (m *ProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyConfig.Merge(m, src)
}
func (m *ProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyConfig proto.InternalMessageInfo

func (m *ProxyConfig) GetAutoInject() string {
	if m != nil {
		return m.AutoInject
	}
	return ""
}

func (m *ProxyConfig) GetClusterDomain() string {
	if m != nil {
		return m.ClusterDomain
	}
	return ""
}

func (m *ProxyConfig) GetComponentLogLevel() string {
	if m != nil {
		return m.ComponentLogLevel
	}
	return ""
}

func (m *ProxyConfig) GetEnableCoreDump() *types.BoolValue {
	if m != nil {
		return m.EnableCoreDump
	}
	return nil
}

func (m *ProxyConfig) GetExcludeInboundPorts() string {
	if m != nil {
		return m.ExcludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetExcludeIPRanges() string {
	if m != nil {
		return m.ExcludeIPRanges
	}
	return ""
}

func (m *ProxyConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ProxyConfig) GetIncludeIPRanges() string {
	if m != nil {
		return m.IncludeIPRanges
	}
	return ""
}

func (m *ProxyConfig) GetLogLevel() string {
	if m != nil {
		return m.LogLevel
	}
	return ""
}

func (m *ProxyConfig) GetPrivileged() *types.BoolValue {
	if m != nil {
		return m.Privileged
	}
	return nil
}

func (m *ProxyConfig) GetReadinessInitialDelaySeconds() uint32 {
	if m != nil {
		return m.ReadinessInitialDelaySeconds
	}
	return 0
}

func (m *ProxyConfig) GetReadinessPeriodSeconds() uint32 {
	if m != nil {
		return m.ReadinessPeriodSeconds
	}
	return 0
}

func (m *ProxyConfig) GetReadinessFailureThreshold() uint32 {
	if m != nil {
		return m.ReadinessFailureThreshold
	}
	return 0
}

func (m *ProxyConfig) GetStatusPort() uint32 {
	if m != nil {
		return m.StatusPort
	}
	return 0
}

// Deprecated: Do not use.
func (m *ProxyConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ProxyConfig) GetTracer() Tracer {
	if m != nil {
		return m.Tracer
	}
	return Tracer_zipkin
}

func (m *ProxyConfig) GetExcludeOutboundPorts() string {
	if m != nil {
		return m.ExcludeOutboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetLifecycle() *types.Struct {
	if m != nil {
		return m.Lifecycle
	}
	return nil
}

// Deprecated: Do not use.
func (m *ProxyConfig) GetHoldApplicationUntilProxyStarts() *types.BoolValue {
	if m != nil {
		return m.HoldApplicationUntilProxyStarts
	}
	return nil
}

func (m *ProxyConfig) GetIncludeInboundPorts() string {
	if m != nil {
		return m.IncludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetIncludeOutboundPorts() string {
	if m != nil {
		return m.IncludeOutboundPorts
	}
	return ""
}

// Configuration for proxy_init container which sets the pods' networking to intercept the inbound/outbound traffic.
type ProxyInitConfig struct {
	// Specifies the image for the proxy_init container.
	Image string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// K8s resources settings.
	//
	// See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources            *Resources `protobuf:"bytes,5,opt,name=resources,proto3" json:"resources,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ProxyInitConfig) Reset()         { *m = ProxyInitConfig{} }
func (m *ProxyInitConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyInitConfig) ProtoMessage()    {}
func (*ProxyInitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{34}
}
func (m *ProxyInitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyInitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyInitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyInitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyInitConfig.Merge(m, src)
}
func (m *ProxyInitConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyInitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyInitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyInitConfig proto.InternalMessageInfo

func (m *ProxyInitConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// Deprecated: Do not use.
func (m *ProxyInitConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

// Configuration for K8s resource requests.
type ResourcesRequestsConfig struct {
	Cpu                  string   `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory               string   `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcesRequestsConfig) Reset()         { *m = ResourcesRequestsConfig{} }
func (m *ResourcesRequestsConfig) String() string { return proto.CompactTextString(m) }
func (*ResourcesRequestsConfig) ProtoMessage()    {}
func (*ResourcesRequestsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{35}
}
func (m *ResourcesRequestsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesRequestsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesRequestsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesRequestsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesRequestsConfig.Merge(m, src)
}
func (m *ResourcesRequestsConfig) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesRequestsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesRequestsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesRequestsConfig proto.InternalMessageInfo

func (m *ResourcesRequestsConfig) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *ResourcesRequestsConfig) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

// Configuration for the SecretDiscoveryService instead of using K8S secrets to mount the certificates.
type SDSConfig struct {
	Token                *types.Struct `protobuf:"bytes,5,opt,name=token,proto3" json:"token,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SDSConfig) Reset()         { *m = SDSConfig{} }
func (m *SDSConfig) String() string { return proto.CompactTextString(m) }
func (*SDSConfig) ProtoMessage()    {}
func (*SDSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{36}
}
func (m *SDSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SDSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SDSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SDSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SDSConfig.Merge(m, src)
}
func (m *SDSConfig) XXX_Size() int {
	return m.Size()
}
func (m *SDSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SDSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SDSConfig proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SDSConfig) GetToken() *types.Struct {
	if m != nil {
		return m.Token
	}
	return nil
}

// Configuration for secret volume mounts.
//
// See https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets.
type SecretVolume struct {
	MountPath            string   `protobuf:"bytes,1,opt,name=mountPath,proto3" json:"mountPath,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	SecretName           string   `protobuf:"bytes,3,opt,name=secretName,proto3" json:"secretName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretVolume) Reset()         { *m = SecretVolume{} }
func (m *SecretVolume) String() string { return proto.CompactTextString(m) }
func (*SecretVolume) ProtoMessage()    {}
func (*SecretVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{37}
}
func (m *SecretVolume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretVolume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretVolume.Merge(m, src)
}
func (m *SecretVolume) XXX_Size() int {
	return m.Size()
}
func (m *SecretVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretVolume.DiscardUnknown(m)
}

var xxx_messageInfo_SecretVolume proto.InternalMessageInfo

func (m *SecretVolume) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *SecretVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretVolume) GetSecretName() string {
	if m != nil {
		return m.SecretName
	}
	return ""
}

// ServiceConfig is described in istio.io documentation.
type ServiceConfig struct {
	Annotations          *types.Struct `protobuf:"bytes,1,opt,name=annotations,proto3" json:"annotations,omitempty"`
	ExternalPort         uint32        `protobuf:"varint,2,opt,name=externalPort,proto3" json:"externalPort,omitempty"`
	Name                 string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string        `protobuf:"bytes,18,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ServiceConfig) Reset()         { *m = ServiceConfig{} }
func (m *ServiceConfig) String() string { return proto.CompactTextString(m) }
func (*ServiceConfig) ProtoMessage()    {}
func (*ServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{38}
}
func (m *ServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConfig.Merge(m, src)
}
func (m *ServiceConfig) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConfig proto.InternalMessageInfo

func (m *ServiceConfig) GetAnnotations() *types.Struct {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceConfig) GetExternalPort() uint32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *ServiceConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// SidecarInjectorConfig is described in istio.io documentation.
type SidecarInjectorConfig struct {
	// Enables sidecar auto-injection in namespaces by default.
	EnableNamespacesByDefault *types.BoolValue `protobuf:"bytes,2,opt,name=enableNamespacesByDefault,proto3" json:"enableNamespacesByDefault,omitempty"`
	// Instructs Istio to not inject the sidecar on those pods, based on labels that are present in those pods.
	//
	// Annotations in the pods have higher precedence than the label selectors.
	// Order of evaluation: Pod Annotations → NeverInjectSelector → AlwaysInjectSelector → Default Policy.
	// See https://istio.io/docs/setup/kubernetes/additional-setup/sidecar-injection/#more-control-adding-exceptions
	NeverInjectSelector []*types.Struct `protobuf:"bytes,11,rep,name=neverInjectSelector,proto3" json:"neverInjectSelector,omitempty"`
	// See NeverInjectSelector.
	AlwaysInjectSelector []*types.Struct `protobuf:"bytes,12,rep,name=alwaysInjectSelector,proto3" json:"alwaysInjectSelector,omitempty"`
	//  If true, webhook or istioctl injector will rewrite PodSpec for liveness health check to redirect request to sidecar. This makes liveness check work even when mTLS is enabled.
	RewriteAppHTTPProbe *types.BoolValue `protobuf:"bytes,16,opt,name=rewriteAppHTTPProbe,proto3" json:"rewriteAppHTTPProbe,omitempty"`
	// injectedAnnotations are additional annotations that will be added to the pod spec after injection
	// This is primarily to support PSP annotations.
	InjectedAnnotations *types.Struct `protobuf:"bytes,19,opt,name=injectedAnnotations,proto3" json:"injectedAnnotations,omitempty"`
	// Enable objectSelector to filter out pods with no need for sidecar before calling istio-sidecar-injector.
	ObjectSelector *types.Struct `protobuf:"bytes,21,opt,name=objectSelector,proto3" json:"objectSelector,omitempty"`
	// Configure the injection url for sidecar injector webhook
	InjectionURL string `protobuf:"bytes,22,opt,name=injectionURL,proto3" json:"injectionURL,omitempty"`
	// Templates defines a set of custom injection templates that can be used. For example, defining:
	//
	// templates:
	//   hello: |
	//     metadata:
	//       labels:
	//         hello: world
	//
	// Then starting a pod with the `inject.istio.io/templates: hello` annotation, will result in the pod
	// being injected with the hello=world labels.
	// This is intended for advanced configuration only; most users should use the built in template
	Templates *types.Struct `protobuf:"bytes,23,opt,name=templates,proto3" json:"templates,omitempty"`
	// defaultTemplates: ["sidecar", "hello"]
	DefaultTemplates []string `protobuf:"bytes,24,rep,name=defaultTemplates,proto3" json:"defaultTemplates,omitempty"`
	// If enabled, the legacy webhook selection logic will be used. This relies on filtering of webhook
	// requests in Istiod, rather than at the webhook selection level.
	// This is option is intended for migration purposes only and will be removed in Istio 1.10.
	UseLegacySelectors   *types.BoolValue `protobuf:"bytes,4,opt,name=useLegacySelectors,proto3" json:"useLegacySelectors,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SidecarInjectorConfig) Reset()         { *m = SidecarInjectorConfig{} }
func (m *SidecarInjectorConfig) String() string { return proto.CompactTextString(m) }
func (*SidecarInjectorConfig) ProtoMessage()    {}
func (*SidecarInjectorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{39}
}
func (m *SidecarInjectorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarInjectorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarInjectorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarInjectorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarInjectorConfig.Merge(m, src)
}
func (m *SidecarInjectorConfig) XXX_Size() int {
	return m.Size()
}
func (m *SidecarInjectorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarInjectorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarInjectorConfig proto.InternalMessageInfo

func (m *SidecarInjectorConfig) GetEnableNamespacesByDefault() *types.BoolValue {
	if m != nil {
		return m.EnableNamespacesByDefault
	}
	return nil
}

func (m *SidecarInjectorConfig) GetNeverInjectSelector() []*types.Struct {
	if m != nil {
		return m.NeverInjectSelector
	}
	return nil
}

func (m *SidecarInjectorConfig) GetAlwaysInjectSelector() []*types.Struct {
	if m != nil {
		return m.AlwaysInjectSelector
	}
	return nil
}

func (m *SidecarInjectorConfig) GetRewriteAppHTTPProbe() *types.BoolValue {
	if m != nil {
		return m.RewriteAppHTTPProbe
	}
	return nil
}

func (m *SidecarInjectorConfig) GetInjectedAnnotations() *types.Struct {
	if m != nil {
		return m.InjectedAnnotations
	}
	return nil
}

func (m *SidecarInjectorConfig) GetObjectSelector() *types.Struct {
	if m != nil {
		return m.ObjectSelector
	}
	return nil
}

func (m *SidecarInjectorConfig) GetInjectionURL() string {
	if m != nil {
		return m.InjectionURL
	}
	return ""
}

func (m *SidecarInjectorConfig) GetTemplates() *types.Struct {
	if m != nil {
		return m.Templates
	}
	return nil
}

func (m *SidecarInjectorConfig) GetDefaultTemplates() []string {
	if m != nil {
		return m.DefaultTemplates
	}
	return nil
}

// Deprecated: Do not use.
func (m *SidecarInjectorConfig) GetUseLegacySelectors() *types.BoolValue {
	if m != nil {
		return m.UseLegacySelectors
	}
	return nil
}

// Configuration for each of the supported tracers.
type TracerConfig struct {
	// Configuration for the datadog tracing service.
	Datadog *TracerDatadogConfig `protobuf:"bytes,1,opt,name=datadog,proto3" json:"datadog,omitempty"`
	// Configuration for the lightstep tracing service.
	Lightstep *TracerLightStepConfig `protobuf:"bytes,2,opt,name=lightstep,proto3" json:"lightstep,omitempty"`
	// Configuration for the zipkin tracing service.
	Zipkin *TracerZipkinConfig `protobuf:"bytes,3,opt,name=zipkin,proto3" json:"zipkin,omitempty"`
	// Configuration for the stackdriver tracing service.
	Stackdriver          *TracerStackdriverConfig `protobuf:"bytes,4,opt,name=stackdriver,proto3" json:"stackdriver,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TracerConfig) Reset()         { *m = TracerConfig{} }
func (m *TracerConfig) String() string { return proto.CompactTextString(m) }
func (*TracerConfig) ProtoMessage()    {}
func (*TracerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{40}
}
func (m *TracerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerConfig.Merge(m, src)
}
func (m *TracerConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerConfig proto.InternalMessageInfo

func (m *TracerConfig) GetDatadog() *TracerDatadogConfig {
	if m != nil {
		return m.Datadog
	}
	return nil
}

func (m *TracerConfig) GetLightstep() *TracerLightStepConfig {
	if m != nil {
		return m.Lightstep
	}
	return nil
}

func (m *TracerConfig) GetZipkin() *TracerZipkinConfig {
	if m != nil {
		return m.Zipkin
	}
	return nil
}

func (m *TracerConfig) GetStackdriver() *TracerStackdriverConfig {
	if m != nil {
		return m.Stackdriver
	}
	return nil
}

// Configuration for the datadog tracing service.
type TracerDatadogConfig struct {
	// Address in host:port format for reporting trace data to the Datadog agent.
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerDatadogConfig) Reset()         { *m = TracerDatadogConfig{} }
func (m *TracerDatadogConfig) String() string { return proto.CompactTextString(m) }
func (*TracerDatadogConfig) ProtoMessage()    {}
func (*TracerDatadogConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{41}
}
func (m *TracerDatadogConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerDatadogConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerDatadogConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerDatadogConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerDatadogConfig.Merge(m, src)
}
func (m *TracerDatadogConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerDatadogConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerDatadogConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerDatadogConfig proto.InternalMessageInfo

func (m *TracerDatadogConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// Configuration for the lightstep tracing service.
type TracerLightStepConfig struct {
	// Sets the lightstep satellite pool address in host:port format for reporting trace data.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Sets the lightstep access token.
	AccessToken          string   `protobuf:"bytes,2,opt,name=accessToken,proto3" json:"accessToken,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerLightStepConfig) Reset()         { *m = TracerLightStepConfig{} }
func (m *TracerLightStepConfig) String() string { return proto.CompactTextString(m) }
func (*TracerLightStepConfig) ProtoMessage()    {}
func (*TracerLightStepConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{42}
}
func (m *TracerLightStepConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerLightStepConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerLightStepConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerLightStepConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerLightStepConfig.Merge(m, src)
}
func (m *TracerLightStepConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerLightStepConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerLightStepConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerLightStepConfig proto.InternalMessageInfo

func (m *TracerLightStepConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *TracerLightStepConfig) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

// Configuration for the zipkin tracing service.
type TracerZipkinConfig struct {
	// Address of zipkin instance in host:port format for reporting trace data.
	//
	// Example: <zipkin-collector-service>.<zipkin-collector-namespace>:941
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerZipkinConfig) Reset()         { *m = TracerZipkinConfig{} }
func (m *TracerZipkinConfig) String() string { return proto.CompactTextString(m) }
func (*TracerZipkinConfig) ProtoMessage()    {}
func (*TracerZipkinConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{43}
}
func (m *TracerZipkinConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerZipkinConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerZipkinConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerZipkinConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerZipkinConfig.Merge(m, src)
}
func (m *TracerZipkinConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerZipkinConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerZipkinConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerZipkinConfig proto.InternalMessageInfo

func (m *TracerZipkinConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// Configuration for the stackdriver tracing service.
type TracerStackdriverConfig struct {
	// enables trace output to stdout.
	Debug *types.BoolValue `protobuf:"bytes,1,opt,name=debug,proto3" json:"debug,omitempty"`
	// The global default max number of attributes per span.
	MaxNumberOfAttributes uint32 `protobuf:"varint,2,opt,name=maxNumberOfAttributes,proto3" json:"maxNumberOfAttributes,omitempty"`
	// The global default max number of annotation events per span.
	MaxNumberOfAnnotations uint32 `protobuf:"varint,3,opt,name=maxNumberOfAnnotations,proto3" json:"maxNumberOfAnnotations,omitempty"`
	// The global default max number of message events per span.
	MaxNumberOfMessageEvents uint32   `protobuf:"varint,4,opt,name=maxNumberOfMessageEvents,proto3" json:"maxNumberOfMessageEvents,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *TracerStackdriverConfig) Reset()         { *m = TracerStackdriverConfig{} }
func (m *TracerStackdriverConfig) String() string { return proto.CompactTextString(m) }
func (*TracerStackdriverConfig) ProtoMessage()    {}
func (*TracerStackdriverConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{44}
}
func (m *TracerStackdriverConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerStackdriverConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerStackdriverConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerStackdriverConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerStackdriverConfig.Merge(m, src)
}
func (m *TracerStackdriverConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerStackdriverConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerStackdriverConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerStackdriverConfig proto.InternalMessageInfo

func (m *TracerStackdriverConfig) GetDebug() *types.BoolValue {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *TracerStackdriverConfig) GetMaxNumberOfAttributes() uint32 {
	if m != nil {
		return m.MaxNumberOfAttributes
	}
	return 0
}

func (m *TracerStackdriverConfig) GetMaxNumberOfAnnotations() uint32 {
	if m != nil {
		return m.MaxNumberOfAnnotations
	}
	return 0
}

func (m *TracerStackdriverConfig) GetMaxNumberOfMessageEvents() uint32 {
	if m != nil {
		return m.MaxNumberOfMessageEvents
	}
	return 0
}

type BaseConfig struct {
	// For Helm2 use, adds the CRDs to templates.
	EnableCRDTemplates *types.BoolValue `protobuf:"bytes,1,opt,name=enableCRDTemplates,proto3" json:"enableCRDTemplates,omitempty"`
	// URL to use for validating webhook.
	ValidationURL string `protobuf:"bytes,2,opt,name=validationURL,proto3" json:"validationURL,omitempty"`
	// For istioctl usage to disable istio config crds in base
	EnableIstioConfigCRDs *types.BoolValue `protobuf:"bytes,3,opt,name=enableIstioConfigCRDs,proto3" json:"enableIstioConfigCRDs,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *BaseConfig) Reset()         { *m = BaseConfig{} }
func (m *BaseConfig) String() string { return proto.CompactTextString(m) }
func (*BaseConfig) ProtoMessage()    {}
func (*BaseConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{45}
}
func (m *BaseConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseConfig.Merge(m, src)
}
func (m *BaseConfig) XXX_Size() int {
	return m.Size()
}
func (m *BaseConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BaseConfig proto.InternalMessageInfo

func (m *BaseConfig) GetEnableCRDTemplates() *types.BoolValue {
	if m != nil {
		return m.EnableCRDTemplates
	}
	return nil
}

func (m *BaseConfig) GetValidationURL() string {
	if m != nil {
		return m.ValidationURL
	}
	return ""
}

func (m *BaseConfig) GetEnableIstioConfigCRDs() *types.BoolValue {
	if m != nil {
		return m.EnableIstioConfigCRDs
	}
	return nil
}

type IstiodRemoteConfig struct {
	// URL to use for sidecar injector webhook.
	InjectionURL string `protobuf:"bytes,1,opt,name=injectionURL,proto3" json:"injectionURL,omitempty"`
	// Path to use for the sidecar injector webhook service.
	InjectionPath        string   `protobuf:"bytes,2,opt,name=injectionPath,proto3" json:"injectionPath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IstiodRemoteConfig) Reset()         { *m = IstiodRemoteConfig{} }
func (m *IstiodRemoteConfig) String() string { return proto.CompactTextString(m) }
func (*IstiodRemoteConfig) ProtoMessage()    {}
func (*IstiodRemoteConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{46}
}
func (m *IstiodRemoteConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstiodRemoteConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstiodRemoteConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstiodRemoteConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstiodRemoteConfig.Merge(m, src)
}
func (m *IstiodRemoteConfig) XXX_Size() int {
	return m.Size()
}
func (m *IstiodRemoteConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IstiodRemoteConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IstiodRemoteConfig proto.InternalMessageInfo

func (m *IstiodRemoteConfig) GetInjectionURL() string {
	if m != nil {
		return m.InjectionURL
	}
	return ""
}

func (m *IstiodRemoteConfig) GetInjectionPath() string {
	if m != nil {
		return m.InjectionPath
	}
	return ""
}

type Values struct {
	Cni      *CNIConfig      `protobuf:"bytes,2,opt,name=cni,proto3" json:"cni,omitempty"`
	Gateways *GatewaysConfig `protobuf:"bytes,5,opt,name=gateways,proto3" json:"gateways,omitempty"`
	Global   *GlobalConfig   `protobuf:"bytes,6,opt,name=global,proto3" json:"global,omitempty"`
	Pilot    *PilotConfig    `protobuf:"bytes,10,opt,name=pilot,proto3" json:"pilot,omitempty"`
	// Controls whether telemetry is exported for Pilot.
	Telemetry              *TelemetryConfig       `protobuf:"bytes,23,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	SidecarInjectorWebhook *SidecarInjectorConfig `protobuf:"bytes,13,opt,name=sidecarInjectorWebhook,proto3" json:"sidecarInjectorWebhook,omitempty"`
	IstioCni               *CNIConfig             `protobuf:"bytes,19,opt,name=istio_cni,json=istioCni,proto3" json:"istio_cni,omitempty"`
	Revision               string                 `protobuf:"bytes,21,opt,name=revision,proto3" json:"revision,omitempty"`
	OwnerName              string                 `protobuf:"bytes,22,opt,name=ownerName,proto3" json:"ownerName,omitempty"`
	// TODO can this import the real mesh config API?
	MeshConfig      *types.Value        `protobuf:"bytes,36,opt,name=meshConfig,proto3" json:"meshConfig,omitempty"`
	Base            *BaseConfig         `protobuf:"bytes,37,opt,name=base,proto3" json:"base,omitempty"`
	IstiodRemote    *IstiodRemoteConfig `protobuf:"bytes,38,opt,name=istiodRemote,proto3" json:"istiodRemote,omitempty"`
	RevisionTags    []string            `protobuf:"bytes,39,rep,name=revisionTags,proto3" json:"revisionTags,omitempty"`
	DefaultRevision string              `protobuf:"bytes,40,opt,name=defaultRevision,proto3" json:"defaultRevision,omitempty"`
	// HSM is ASM-specific feature, start from 100 to avoid conflicts.
	Hsm *HSMConfig `protobuf:"bytes,100,opt,name=hsm,proto3" json:"hsm,omitempty"`
	// Managed Data Plane (MDP) config is ASM-specific.
	Mdp                  *MDPConfig `protobuf:"bytes,101,opt,name=mdp,proto3" json:"mdp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Values) Reset()         { *m = Values{} }
func (m *Values) String() string { return proto.CompactTextString(m) }
func (*Values) ProtoMessage()    {}
func (*Values) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{47}
}
func (m *Values) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Values) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Values.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Values) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Values.Merge(m, src)
}
func (m *Values) XXX_Size() int {
	return m.Size()
}
func (m *Values) XXX_DiscardUnknown() {
	xxx_messageInfo_Values.DiscardUnknown(m)
}

var xxx_messageInfo_Values proto.InternalMessageInfo

func (m *Values) GetCni() *CNIConfig {
	if m != nil {
		return m.Cni
	}
	return nil
}

func (m *Values) GetGateways() *GatewaysConfig {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *Values) GetGlobal() *GlobalConfig {
	if m != nil {
		return m.Global
	}
	return nil
}

func (m *Values) GetPilot() *PilotConfig {
	if m != nil {
		return m.Pilot
	}
	return nil
}

func (m *Values) GetTelemetry() *TelemetryConfig {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

func (m *Values) GetSidecarInjectorWebhook() *SidecarInjectorConfig {
	if m != nil {
		return m.SidecarInjectorWebhook
	}
	return nil
}

func (m *Values) GetIstioCni() *CNIConfig {
	if m != nil {
		return m.IstioCni
	}
	return nil
}

func (m *Values) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *Values) GetOwnerName() string {
	if m != nil {
		return m.OwnerName
	}
	return ""
}

func (m *Values) GetMeshConfig() *types.Value {
	if m != nil {
		return m.MeshConfig
	}
	return nil
}

func (m *Values) GetBase() *BaseConfig {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *Values) GetIstiodRemote() *IstiodRemoteConfig {
	if m != nil {
		return m.IstiodRemote
	}
	return nil
}

func (m *Values) GetRevisionTags() []string {
	if m != nil {
		return m.RevisionTags
	}
	return nil
}

func (m *Values) GetDefaultRevision() string {
	if m != nil {
		return m.DefaultRevision
	}
	return ""
}

func (m *Values) GetHsm() *HSMConfig {
	if m != nil {
		return m.Hsm
	}
	return nil
}

func (m *Values) GetMdp() *MDPConfig {
	if m != nil {
		return m.Mdp
	}
	return nil
}

// ZeroVPNConfig enables cross-cluster access using SNI matching.
type ZeroVPNConfig struct {
	// Controls whether ZeroVPN is enabled.
	Enabled              *types.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Suffix               string           `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ZeroVPNConfig) Reset()         { *m = ZeroVPNConfig{} }
func (m *ZeroVPNConfig) String() string { return proto.CompactTextString(m) }
func (*ZeroVPNConfig) ProtoMessage()    {}
func (*ZeroVPNConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{48}
}
func (m *ZeroVPNConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroVPNConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroVPNConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroVPNConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroVPNConfig.Merge(m, src)
}
func (m *ZeroVPNConfig) XXX_Size() int {
	return m.Size()
}
func (m *ZeroVPNConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroVPNConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroVPNConfig proto.InternalMessageInfo

func (m *ZeroVPNConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *ZeroVPNConfig) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

// IntOrString is a type that can hold an int32 or a string.  When used in
// JSON or YAML marshalling and unmarshalling, it produces or consumes the
// inner type.  This allows you to have, for example, a JSON field that can
// accept a name or number.
// TODO: Rename to Int32OrString
//
// +protobuf=true
// +protobuf.options.(gogoproto.goproto_stringer)=false
// +k8s:openapi-gen=true
type IntOrString struct {
	Type                 int64              `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	IntVal               *types.Int32Value  `protobuf:"bytes,2,opt,name=intVal,proto3" json:"intVal,omitempty"`
	StrVal               *types.StringValue `protobuf:"bytes,3,opt,name=strVal,proto3" json:"strVal,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *IntOrString) Reset()         { *m = IntOrString{} }
func (m *IntOrString) String() string { return proto.CompactTextString(m) }
func (*IntOrString) ProtoMessage()    {}
func (*IntOrString) Descriptor() ([]byte, []int) {
	return fileDescriptor_261260e22432516f, []int{49}
}
func (m *IntOrString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntOrString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntOrString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntOrString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntOrString.Merge(m, src)
}
func (m *IntOrString) XXX_Size() int {
	return m.Size()
}
func (m *IntOrString) XXX_DiscardUnknown() {
	xxx_messageInfo_IntOrString.DiscardUnknown(m)
}

var xxx_messageInfo_IntOrString proto.InternalMessageInfo

func (m *IntOrString) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IntOrString) GetIntVal() *types.Int32Value {
	if m != nil {
		return m.IntVal
	}
	return nil
}

func (m *IntOrString) GetStrVal() *types.StringValue {
	if m != nil {
		return m.StrVal
	}
	return nil
}

func init() {
	proto.RegisterEnum("v1alpha1.IngressControllerMode", IngressControllerMode_name, IngressControllerMode_value)
	proto.RegisterEnum("v1alpha1.Tracer", Tracer_name, Tracer_value)
	proto.RegisterEnum("v1alpha1.OutboundTrafficPolicyConfig_Mode", OutboundTrafficPolicyConfig_Mode_name, OutboundTrafficPolicyConfig_Mode_value)
	proto.RegisterEnum("v1alpha1.TelemetryV2StackDriverConfig_AccessLogging", TelemetryV2StackDriverConfig_AccessLogging_name, TelemetryV2StackDriverConfig_AccessLogging_value)
	proto.RegisterType((*ArchConfig)(nil), "v1alpha1.ArchConfig")
	proto.RegisterType((*CNIConfig)(nil), "v1alpha1.CNIConfig")
	proto.RegisterType((*CNITaintConfig)(nil), "v1alpha1.CNITaintConfig")
	proto.RegisterType((*CNIRepairConfig)(nil), "v1alpha1.CNIRepairConfig")
	proto.RegisterType((*ResourceQuotas)(nil), "v1alpha1.ResourceQuotas")
	proto.RegisterType((*CPUTargetUtilizationConfig)(nil), "v1alpha1.CPUTargetUtilizationConfig")
	proto.RegisterType((*Resources)(nil), "v1alpha1.Resources")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.LimitsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.RequestsEntry")
	proto.RegisterType((*ServiceAccount)(nil), "v1alpha1.ServiceAccount")
	proto.RegisterType((*DefaultPodDisruptionBudgetConfig)(nil), "v1alpha1.DefaultPodDisruptionBudgetConfig")
	proto.RegisterType((*DefaultResourcesConfig)(nil), "v1alpha1.DefaultResourcesConfig")
	proto.RegisterType((*EgressGatewayConfig)(nil), "v1alpha1.EgressGatewayConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.EgressGatewayConfig.LabelsEntry")
	proto.RegisterType((*GatewaysConfig)(nil), "v1alpha1.GatewaysConfig")
	proto.RegisterType((*GlobalConfig)(nil), "v1alpha1.GlobalConfig")
	proto.RegisterType((*STSConfig)(nil), "v1alpha1.STSConfig")
	proto.RegisterType((*IstiodConfig)(nil), "v1alpha1.IstiodConfig")
	proto.RegisterType((*GlobalLoggingConfig)(nil), "v1alpha1.GlobalLoggingConfig")
	proto.RegisterType((*IngressGatewayConfig)(nil), "v1alpha1.IngressGatewayConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.IngressGatewayConfig.LabelsEntry")
	proto.RegisterType((*IngressGatewayZvpnConfig)(nil), "v1alpha1.IngressGatewayZvpnConfig")
	proto.RegisterType((*MDPConfig)(nil), "v1alpha1.MDPConfig")
	proto.RegisterType((*MultiClusterConfig)(nil), "v1alpha1.MultiClusterConfig")
	proto.RegisterType((*OutboundTrafficPolicyConfig)(nil), "v1alpha1.OutboundTrafficPolicyConfig")
	proto.RegisterType((*PilotConfig)(nil), "v1alpha1.PilotConfig")
	proto.RegisterType((*HSMConfig)(nil), "v1alpha1.HSMConfig")
	proto.RegisterType((*PilotIngressConfig)(nil), "v1alpha1.PilotIngressConfig")
	proto.RegisterType((*PilotPolicyConfig)(nil), "v1alpha1.PilotPolicyConfig")
	proto.RegisterType((*TelemetryConfig)(nil), "v1alpha1.TelemetryConfig")
	proto.RegisterType((*TelemetryV2Config)(nil), "v1alpha1.TelemetryV2Config")
	proto.RegisterType((*TelemetryV2MetadataExchangeConfig)(nil), "v1alpha1.TelemetryV2MetadataExchangeConfig")
	proto.RegisterType((*TelemetryV2PrometheusConfig)(nil), "v1alpha1.TelemetryV2PrometheusConfig")
	proto.RegisterType((*TelemetryV2PrometheusConfig_ConfigOverride)(nil), "v1alpha1.TelemetryV2PrometheusConfig.ConfigOverride")
	proto.RegisterType((*TelemetryV2StackDriverConfig)(nil), "v1alpha1.TelemetryV2StackDriverConfig")
	proto.RegisterType((*TelemetryV2AccessLogPolicyFilterConfig)(nil), "v1alpha1.TelemetryV2AccessLogPolicyFilterConfig")
	proto.RegisterType((*PilotConfigSource)(nil), "v1alpha1.PilotConfigSource")
	proto.RegisterType((*PortsConfig)(nil), "v1alpha1.PortsConfig")
	proto.RegisterType((*ProxyConfig)(nil), "v1alpha1.ProxyConfig")
	proto.RegisterType((*ProxyInitConfig)(nil), "v1alpha1.ProxyInitConfig")
	proto.RegisterType((*ResourcesRequestsConfig)(nil), "v1alpha1.ResourcesRequestsConfig")
	proto.RegisterType((*SDSConfig)(nil), "v1alpha1.SDSConfig")
	proto.RegisterType((*SecretVolume)(nil), "v1alpha1.SecretVolume")
	proto.RegisterType((*ServiceConfig)(nil), "v1alpha1.ServiceConfig")
	proto.RegisterType((*SidecarInjectorConfig)(nil), "v1alpha1.SidecarInjectorConfig")
	proto.RegisterType((*TracerConfig)(nil), "v1alpha1.TracerConfig")
	proto.RegisterType((*TracerDatadogConfig)(nil), "v1alpha1.TracerDatadogConfig")
	proto.RegisterType((*TracerLightStepConfig)(nil), "v1alpha1.TracerLightStepConfig")
	proto.RegisterType((*TracerZipkinConfig)(nil), "v1alpha1.TracerZipkinConfig")
	proto.RegisterType((*TracerStackdriverConfig)(nil), "v1alpha1.TracerStackdriverConfig")
	proto.RegisterType((*BaseConfig)(nil), "v1alpha1.BaseConfig")
	proto.RegisterType((*IstiodRemoteConfig)(nil), "v1alpha1.IstiodRemoteConfig")
	proto.RegisterType((*Values)(nil), "v1alpha1.Values")
	proto.RegisterType((*ZeroVPNConfig)(nil), "v1alpha1.ZeroVPNConfig")
	proto.RegisterType((*IntOrString)(nil), "v1alpha1.IntOrString")
}

func init() {
	proto.RegisterFile("pkg/apis/istio/v1alpha1/values_types.proto", fileDescriptor_261260e22432516f)
}

var fileDescriptor_261260e22432516f = []byte{
	// 5034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x3c, 0x49, 0x73, 0x1b, 0xc7,
	0x7a, 0x06, 0xc1, 0x0d, 0x1f, 0xb8, 0x80, 0xcd, 0x45, 0x23, 0x8a, 0x96, 0xe8, 0xb1, 0xa5, 0xd0,
	0x92, 0x4d, 0x49, 0x34, 0x2d, 0xdb, 0xb2, 0x65, 0x1b, 0xdc, 0x6c, 0x5a, 0x5c, 0x90, 0x01, 0x25,
	0x2f, 0x95, 0x67, 0xbe, 0xe1, 0x4c, 0x13, 0x18, 0x6b, 0x30, 0x3d, 0x6f, 0xba, 0x01, 0x0a, 0x3e,
	0x25, 0xa7, 0x5c, 0xf2, 0x2e, 0xa9, 0x72, 0xaa, 0x72, 0xca, 0x31, 0xa7, 0x54, 0x8e, 0xa9, 0x7a,
	0x7f, 0x20, 0x39, 0xbe, 0x7b, 0xaa, 0x52, 0x29, 0x57, 0x0e, 0xa9, 0xe4, 0x9c, 0x53, 0x2e, 0xa9,
	0x5e, 0x66, 0x30, 0x33, 0x18, 0x2c, 0xa4, 0x5c, 0xaf, 0x52, 0xef, 0x44, 0xf4, 0xb7, 0xf5, 0xfe,
	0x6d, 0xfd, 0x0d, 0xe1, 0xae, 0xff, 0xa2, 0x76, 0xdf, 0xf4, 0x1d, 0x7a, 0xdf, 0xa1, 0xcc, 0x21,
	0xf7, 0x5b, 0x0f, 0x4d, 0xd7, 0xaf, 0x9b, 0x0f, 0xef, 0xb7, 0x4c, 0xb7, 0x89, 0xe9, 0x29, 0x6b,
	0xfb, 0x98, 0xae, 0xfb, 0x01, 0x61, 0x04, 0x4d, 0x86, 0xc8, 0xe5, 0xeb, 0x35, 0x42, 0x6a, 0x2e,
	0xbe, 0x2f, 0xe0, 0x67, 0xcd, 0xf3, 0xfb, 0xa6, 0xd7, 0x96, 0x44, 0xcb, 0x2b, 0x69, 0x14, 0x65,
	0x41, 0xd3, 0x62, 0x0a, 0x7b, 0x33, 0x8d, 0xbd, 0x08, 0x4c, 0xdf, 0xc7, 0x01, 0xed, 0x85, 0xb7,
	0x9b, 0x81, 0xc9, 0x1c, 0xe2, 0x29, 0xfc, 0x42, 0x8d, 0xd4, 0x88, 0xf8, 0x79, 0x9f, 0xff, 0x92,
	0x50, 0xbd, 0x0e, 0x50, 0x0e, 0xac, 0xfa, 0x36, 0xf1, 0xce, 0x9d, 0x1a, 0x5a, 0x80, 0x31, 0xb3,
	0x61, 0x3f, 0xda, 0xd4, 0x72, 0xab, 0xb9, 0xb5, 0x69, 0x43, 0x36, 0x90, 0x06, 0x13, 0xbe, 0x6f,
	0x3d, 0xda, 0x74, 0xb1, 0x36, 0x22, 0xe0, 0x61, 0x93, 0xd3, 0xd3, 0xf7, 0x3e, 0x7a, 0xf0, 0x52,
	0xcb, 0x4b, 0x7a, 0xd1, 0x10, 0x52, 0x82, 0xc6, 0xa3, 0x4d, 0x6d, 0x54, 0x49, 0xe1, 0x0d, 0xfd,
	0xef, 0xc6, 0xa1, 0xb0, 0x7d, 0xb4, 0xaf, 0x7a, 0xda, 0x84, 0x09, 0xec, 0x99, 0x67, 0x2e, 0xb6,
	0x45, 0x5f, 0xc5, 0x8d, 0xe5, 0x75, 0x39, 0xfe, 0xf5, 0x70, 0xfc, 0xeb, 0x5b, 0x84, 0xb8, 0xcf,
	0xf9, 0x52, 0x1a, 0x21, 0x29, 0x2a, 0x41, 0xbe, 0xde, 0x3c, 0x13, 0xa3, 0x28, 0x18, 0xfc, 0x27,
	0x5a, 0x83, 0x3c, 0x33, 0x6b, 0xa2, 0xff, 0xe2, 0xc6, 0x52, 0x97, 0x0c, 0xc9, 0xcf, 0x49, 0xf8,
	0xa8, 0x9c, 0x86, 0x59, 0xc3, 0x62, 0x54, 0x05, 0x43, 0x36, 0xd0, 0x4d, 0x00, 0xbf, 0xe9, 0xba,
	0x15, 0xe2, 0x3a, 0x56, 0x5b, 0x1b, 0x13, 0xa8, 0x18, 0x04, 0xad, 0x40, 0xc1, 0xf2, 0x9c, 0x2d,
	0xc7, 0xdb, 0x71, 0x02, 0x6d, 0x5c, 0xa0, 0x3b, 0x00, 0xce, 0x6d, 0x79, 0x0e, 0x9f, 0x12, 0x47,
	0x4f, 0x48, 0xee, 0x0e, 0x04, 0xad, 0xc1, 0xac, 0x6a, 0xed, 0x39, 0x2e, 0x3e, 0x32, 0x1b, 0x58,
	0x9b, 0x14, 0x44, 0x69, 0x30, 0x7a, 0x07, 0xe6, 0xf0, 0x4b, 0xcb, 0x6d, 0xda, 0xa2, 0x49, 0x7d,
	0xd3, 0xc2, 0x54, 0x2b, 0xac, 0xe6, 0xd7, 0x0a, 0x46, 0x37, 0x02, 0x6d, 0xc3, 0x8c, 0x4f, 0xec,
	0xb2, 0xe7, 0x11, 0x26, 0xb6, 0x98, 0x6a, 0x20, 0x16, 0xe0, 0x5a, 0xd7, 0x02, 0x54, 0xc5, 0x11,
	0xda, 0x1a, 0xd1, 0x72, 0x46, 0x8a, 0x05, 0xad, 0x41, 0xc9, 0xa7, 0xfe, 0xa9, 0xe5, 0x36, 0x29,
	0xc3, 0xc1, 0x69, 0x40, 0x5c, 0xac, 0x15, 0xc5, 0xe8, 0x66, 0x7c, 0xea, 0x6f, 0x4b, 0xb0, 0x41,
	0x5c, 0x8c, 0x96, 0x61, 0xd2, 0x25, 0xb5, 0x03, 0xdc, 0xc2, 0xae, 0x36, 0x25, 0x28, 0xa2, 0x36,
	0x7a, 0x08, 0xe3, 0x01, 0xf6, 0x4d, 0x27, 0xd0, 0xa6, 0xc5, 0x10, 0xae, 0xaf, 0x87, 0x47, 0x7d,
	0x7d, 0xfb, 0x68, 0xdf, 0x10, 0x28, 0xb9, 0xe7, 0x86, 0x22, 0xe4, 0x7b, 0x6f, 0xd5, 0x4d, 0xc7,
	0xc3, 0xb6, 0x36, 0x33, 0x78, 0xef, 0x15, 0x29, 0x5a, 0x87, 0x31, 0x66, 0x3a, 0x1e, 0xd3, 0x66,
	0x05, 0x8f, 0x96, 0xe8, 0xe7, 0x84, 0x63, 0x54, 0x37, 0x92, 0x0c, 0x95, 0x61, 0x36, 0xc0, 0x94,
	0x34, 0x03, 0x0b, 0x9f, 0xfe, 0xa6, 0x49, 0x98, 0x49, 0xb5, 0x52, 0x9a, 0xd3, 0x50, 0x04, 0x7f,
	0x2a, 0xf0, 0xc6, 0x4c, 0x90, 0x68, 0xa3, 0x87, 0x50, 0x08, 0x21, 0x54, 0x9b, 0x13, 0xcc, 0xf3,
	0xdd, 0xcc, 0xd4, 0xe8, 0x50, 0xa1, 0xc7, 0x00, 0x7e, 0xe0, 0xb4, 0x1c, 0x17, 0xd7, 0xb0, 0xad,
	0xa1, 0x81, 0xd3, 0x8b, 0x51, 0xeb, 0x7b, 0x30, 0x93, 0x9c, 0xca, 0xd5, 0x6e, 0x89, 0xfe, 0xdb,
	0x3c, 0xcc, 0xa6, 0xd6, 0xfe, 0xff, 0xcd, 0x7d, 0x5b, 0x81, 0x82, 0x6b, 0x9e, 0x61, 0xb7, 0x42,
	0x6c, 0x2a, 0xae, 0xdb, 0xa4, 0xd1, 0x01, 0xa0, 0x3b, 0x30, 0x65, 0x05, 0xd8, 0x64, 0x78, 0xb7,
	0x85, 0x3d, 0x46, 0xe5, 0x85, 0x13, 0x87, 0x37, 0x01, 0xe7, 0xf7, 0xce, 0xc6, 0x2e, 0x66, 0x58,
	0x88, 0x99, 0x10, 0x62, 0x62, 0x10, 0x7e, 0x9b, 0xce, 0x02, 0xf2, 0x02, 0x7b, 0x15, 0x62, 0x1f,
	0x70, 0xe9, 0x4f, 0x71, 0x5b, 0xdd, 0xbc, 0x6e, 0x04, 0x7a, 0x00, 0xf3, 0x49, 0xa0, 0x98, 0x85,
	0x56, 0x10, 0xf4, 0x59, 0x28, 0x2e, 0xdf, 0xf1, 0x1c, 0xbe, 0x4b, 0xfc, 0xac, 0xe1, 0x40, 0xdc,
	0x6c, 0x90, 0xf2, 0xbb, 0x10, 0xfa, 0x77, 0x30, 0x93, 0x3c, 0x68, 0x57, 0xdc, 0x0d, 0x04, 0xa3,
	0x3e, 0x9f, 0x2f, 0xdf, 0x8e, 0xbc, 0x21, 0x7e, 0xeb, 0xdf, 0xc0, 0xf2, 0x76, 0xe5, 0xd9, 0x89,
	0x19, 0xd4, 0x30, 0x7b, 0xc6, 0x1c, 0xd7, 0xf9, 0x51, 0xdc, 0x6e, 0xb5, 0xeb, 0x8f, 0x41, 0x63,
	0x02, 0x55, 0x6e, 0xe1, 0xc0, 0xac, 0xe1, 0x18, 0x85, 0xe8, 0x78, 0xcc, 0xe8, 0x89, 0xd7, 0xff,
	0x37, 0x07, 0x85, 0xe8, 0x88, 0xa3, 0x0f, 0x60, 0xdc, 0x75, 0x1a, 0x0e, 0xa3, 0x5a, 0x6e, 0x35,
	0xbf, 0x56, 0xdc, 0xb8, 0x95, 0x71, 0x0f, 0xd6, 0x0f, 0x04, 0xc5, 0xae, 0xc7, 0x82, 0xb6, 0xa1,
	0xc8, 0xd1, 0x13, 0x98, 0x0c, 0xf0, 0x6f, 0x9a, 0x98, 0x32, 0x3e, 0x70, 0xce, 0xfa, 0x46, 0x16,
	0xab, 0xa1, 0x68, 0x24, 0x73, 0xc4, 0xb2, 0xfc, 0x11, 0x14, 0x63, 0x52, 0xf9, 0x81, 0x7c, 0x81,
	0xdb, 0x62, 0xec, 0x05, 0x83, 0xff, 0xe4, 0xc7, 0x4c, 0xd8, 0x5b, 0x75, 0x48, 0x65, 0xe3, 0xf1,
	0xc8, 0x87, 0xb9, 0xe5, 0x8f, 0x61, 0x3a, 0x21, 0xf5, 0x32, 0xcc, 0xfa, 0x53, 0x98, 0xa9, 0xe2,
	0xa0, 0xe5, 0x58, 0xb8, 0x6c, 0x59, 0xa4, 0xe9, 0x31, 0xf4, 0x11, 0x14, 0xcd, 0x98, 0xc2, 0xcd,
	0xf5, 0x55, 0xb8, 0x46, 0x9c, 0x56, 0xff, 0x06, 0x56, 0x77, 0xf0, 0xb9, 0xd9, 0x74, 0x59, 0x85,
	0xd8, 0x3b, 0x0e, 0x0d, 0x9a, 0x3e, 0x47, 0x6c, 0x35, 0xed, 0x1a, 0x7e, 0xb5, 0xab, 0xfe, 0x35,
	0x2c, 0x29, 0xc9, 0xd1, 0x52, 0x2a, 0x79, 0xf1, 0x75, 0x97, 0x02, 0xb3, 0xd6, 0x3d, 0x5c, 0x20,
	0xa5, 0x3a, 0x23, 0x16, 0xfd, 0x5f, 0xa7, 0x60, 0x7e, 0xb7, 0x16, 0x60, 0x4a, 0xbf, 0x30, 0x19,
	0xbe, 0x30, 0xdb, 0x4a, 0xec, 0x1e, 0x94, 0xcc, 0x26, 0x23, 0xd4, 0x32, 0x5d, 0xbc, 0x3b, 0xf4,
	0x78, 0xbb, 0x78, 0x90, 0x0e, 0x53, 0x11, 0xec, 0xd0, 0x7c, 0xa9, 0x1c, 0x8b, 0x04, 0x2c, 0x49,
	0xe3, 0x78, 0xca, 0xc9, 0x48, 0xc0, 0xd0, 0x63, 0xc8, 0x5b, 0x7e, 0x53, 0x68, 0x92, 0xe2, 0xc6,
	0x5b, 0x31, 0x9b, 0xd0, 0xf3, 0x52, 0x08, 0x75, 0xc2, 0x99, 0xe2, 0x4b, 0x3e, 0x31, 0xfc, 0x2d,
	0x7c, 0x1b, 0xf2, 0xd8, 0x6b, 0x09, 0x6d, 0xd2, 0x67, 0xff, 0x39, 0x0d, 0x2a, 0xc3, 0xb8, 0xd0,
	0x6d, 0xd2, 0x92, 0x17, 0x37, 0xde, 0xee, 0x8c, 0x2f, 0x63, 0x6d, 0xd7, 0x85, 0x82, 0x89, 0xae,
	0x8f, 0x68, 0xf0, 0x3b, 0xef, 0x71, 0xe5, 0x72, 0x5d, 0x1c, 0x50, 0xf1, 0x1b, 0x7d, 0x06, 0x53,
	0x1e, 0xb1, 0x71, 0x15, 0xbb, 0xd8, 0x62, 0x24, 0x18, 0xc6, 0xf6, 0x27, 0x18, 0x32, 0xdc, 0x87,
	0xe2, 0xe5, 0xdd, 0x87, 0x53, 0x58, 0x11, 0x10, 0xe6, 0x94, 0xcf, 0xcf, 0xb9, 0xd2, 0x6b, 0x8b,
	0xf1, 0x47, 0xa3, 0x9a, 0x12, 0x53, 0xee, 0x2b, 0xb2, 0xaf, 0x00, 0x54, 0x83, 0xd5, 0x14, 0xfe,
	0x04, 0x07, 0x8d, 0x64, 0x27, 0xd3, 0x83, 0x3b, 0x19, 0x28, 0x04, 0xdd, 0x83, 0x31, 0x9f, 0x04,
	0x8c, 0x6a, 0x33, 0x42, 0xda, 0x62, 0x67, 0x97, 0x2a, 0x1c, 0x1c, 0xba, 0x15, 0x82, 0x06, 0xbd,
	0x1f, 0xf7, 0x09, 0x66, 0x7b, 0xfa, 0x04, 0xa2, 0xeb, 0x98, 0x5f, 0xf0, 0x09, 0x4c, 0x53, 0x6c,
	0x05, 0x98, 0x3d, 0x27, 0x6e, 0xb3, 0x81, 0xb9, 0x2f, 0x92, 0x17, 0x16, 0x34, 0x62, 0xad, 0xc6,
	0xd0, 0x46, 0x92, 0x18, 0x7d, 0x01, 0x88, 0x2a, 0x6d, 0x14, 0xdb, 0xb4, 0xb9, 0xfe, 0x47, 0x30,
	0x83, 0x85, 0x1f, 0x27, 0x1e, 0x96, 0x08, 0xc7, 0xa4, 0x60, 0x88, 0xdf, 0xe8, 0x1e, 0x8c, 0xfe,
	0xd8, 0xf2, 0x3d, 0x6d, 0x5e, 0x89, 0x8b, 0x46, 0xf4, 0x1d, 0x0e, 0xc8, 0xf3, 0xca, 0x91, 0x9a,
	0xbf, 0x20, 0x42, 0x4f, 0xa0, 0xc8, 0x88, 0x8b, 0x03, 0x35, 0x84, 0x85, 0xc1, 0xeb, 0x1f, 0xa7,
	0x47, 0xdb, 0x30, 0x1b, 0x10, 0xd7, 0x75, 0xbc, 0xda, 0xa1, 0xf9, 0xb2, 0xda, 0x0c, 0x6a, 0x58,
	0x5b, 0x14, 0xdd, 0xc6, 0x16, 0x7d, 0xdf, 0x63, 0xc7, 0x41, 0x95, 0x05, 0x8e, 0x27, 0xef, 0x6a,
	0x9a, 0x03, 0x1d, 0xc3, 0x62, 0x07, 0xf4, 0xcc, 0x33, 0x5b, 0xa6, 0xe3, 0xf2, 0xbb, 0xa9, 0x2d,
	0x0d, 0x12, 0x95, 0xcd, 0x87, 0x9e, 0xc0, 0xb4, 0x25, 0x26, 0x19, 0x6e, 0xce, 0xb5, 0xbe, 0xd3,
	0x32, 0x92, 0xd4, 0xe8, 0x29, 0x2c, 0x98, 0xb6, 0xed, 0xf0, 0x19, 0x9a, 0x6e, 0x64, 0xfa, 0xa9,
	0xa6, 0xf5, 0x97, 0x92, 0xc9, 0x84, 0x3e, 0x84, 0x42, 0xd0, 0xf4, 0xca, 0xd4, 0x20, 0x84, 0x69,
	0xcb, 0x03, 0xd5, 0x52, 0x87, 0x58, 0x3a, 0x25, 0x3f, 0x60, 0x8b, 0x8b, 0x3c, 0xc1, 0x0d, 0xdf,
	0x35, 0x19, 0xd6, 0x6e, 0x84, 0x4e, 0x49, 0x0a, 0x81, 0x3e, 0x87, 0x19, 0x9a, 0x30, 0x70, 0xda,
	0x4a, 0xda, 0x3b, 0x4e, 0x1a, 0x40, 0x23, 0x45, 0x2f, 0x4c, 0x73, 0x47, 0x63, 0x5d, 0xca, 0xba,
	0xfe, 0x77, 0x0e, 0x66, 0x94, 0xee, 0x0b, 0xed, 0xd5, 0x31, 0xcc, 0x8b, 0x30, 0xfa, 0x14, 0x0b,
	0xcd, 0x58, 0x93, 0x58, 0x65, 0x5b, 0x5e, 0xef, 0xab, 0x38, 0x0d, 0xc9, 0xf9, 0x6e, 0x82, 0x33,
	0xae, 0xdd, 0x47, 0x86, 0xd7, 0xee, 0x06, 0x2c, 0xc8, 0x61, 0x38, 0x5e, 0x62, 0x1c, 0xa3, 0x42,
	0xc4, 0xcd, 0xf8, 0xd1, 0xca, 0x18, 0x88, 0xe4, 0x7d, 0x37, 0xc9, 0xab, 0xff, 0x34, 0x07, 0x53,
	0x5f, 0xb8, 0xe4, 0x4c, 0xec, 0x33, 0x9f, 0xeb, 0x3b, 0x30, 0x6a, 0x06, 0x56, 0x5d, 0x4d, 0x6e,
	0xa1, 0x23, 0xb4, 0x13, 0x8a, 0x8b, 0xe3, 0x2a, 0xa8, 0xb8, 0x7b, 0x2a, 0xcf, 0x1b, 0xdf, 0xe5,
	0x28, 0x08, 0xd4, 0x36, 0xa4, 0x7b, 0x9a, 0x81, 0xe2, 0x46, 0x5a, 0x9d, 0x50, 0xd3, 0x75, 0x6c,
	0xe9, 0xee, 0xe5, 0x07, 0x1b, 0xe9, 0x34, 0x0f, 0xfa, 0x12, 0x6e, 0xd9, 0xd2, 0xbb, 0x90, 0x83,
	0x7a, 0xee, 0x50, 0xe7, 0xcc, 0x71, 0x1d, 0xd6, 0xae, 0x62, 0xc6, 0x1c, 0xaf, 0x46, 0xb5, 0x4d,
	0x11, 0xa2, 0x0e, 0x22, 0x43, 0x87, 0x30, 0xaf, 0x48, 0x8e, 0xe2, 0x96, 0x6b, 0x7c, 0xb0, 0xd9,
	0xc9, 0xe2, 0x43, 0x1e, 0x2c, 0xdb, 0x3d, 0x1d, 0x2a, 0x65, 0xcc, 0xef, 0x76, 0x96, 0x75, 0x90,
	0xf3, 0x25, 0x3a, 0xea, 0x23, 0x11, 0x55, 0xa0, 0x64, 0xa7, 0xdc, 0x2c, 0x11, 0x1e, 0x14, 0x37,
	0x56, 0xbb, 0x7a, 0x49, 0x39, 0x62, 0x42, 0x76, 0x17, 0x37, 0x7a, 0x0a, 0x48, 0xc1, 0x4e, 0x62,
	0xea, 0xf4, 0x83, 0xc1, 0xea, 0x34, 0x83, 0x2d, 0x0c, 0xd3, 0xa6, 0xe2, 0x61, 0xda, 0xac, 0x88,
	0xb7, 0x2a, 0x9d, 0xdc, 0xc6, 0xb4, 0x4c, 0x3c, 0xa4, 0xc0, 0xe8, 0x2e, 0x94, 0x22, 0x90, 0x34,
	0x41, 0x54, 0xbb, 0x2d, 0x36, 0xb5, 0x0b, 0x8e, 0xee, 0xc0, 0x8c, 0x38, 0xe0, 0x9d, 0x43, 0x38,
	0x23, 0xf3, 0x05, 0x49, 0x28, 0xd7, 0x61, 0x2e, 0xa9, 0x95, 0xe9, 0x57, 0x94, 0x78, 0xda, 0x5b,
	0x83, 0x75, 0x58, 0x44, 0x8c, 0x3e, 0x80, 0x09, 0x97, 0xd4, 0x6a, 0x8e, 0x57, 0x53, 0xd6, 0x2d,
	0x76, 0xf3, 0xe5, 0x15, 0x3a, 0x90, 0x68, 0x75, 0xe1, 0x42, 0x6a, 0xb4, 0x04, 0xe3, 0x0d, 0x4c,
	0xeb, 0xfb, 0x3b, 0xda, 0xfb, 0x62, 0x48, 0xaa, 0x85, 0x3e, 0x86, 0x29, 0xfe, 0xeb, 0x08, 0xb3,
	0x0b, 0x12, 0xbc, 0xa0, 0x91, 0x91, 0xeb, 0xa1, 0x93, 0x13, 0xc4, 0xe8, 0x73, 0x98, 0x6a, 0x34,
	0x5d, 0xe6, 0xa8, 0x5c, 0x88, 0xb2, 0x2f, 0x2b, 0x9d, 0x21, 0x1d, 0xc6, 0xb0, 0x6a, 0x44, 0x09,
	0x0e, 0xa4, 0xc1, 0x84, 0x27, 0xa5, 0x69, 0x7f, 0x22, 0xc6, 0x15, 0x36, 0xd1, 0x23, 0x58, 0xf2,
	0x89, 0xbd, 0x73, 0x54, 0xad, 0x62, 0x7e, 0xcb, 0x63, 0x59, 0x9f, 0x7b, 0x62, 0xf5, 0x7b, 0x60,
	0xd1, 0xf7, 0xb0, 0x42, 0x1a, 0x0e, 0xab, 0x3a, 0x36, 0xb6, 0xcc, 0x60, 0x5f, 0xe8, 0x75, 0xa2,
	0x3a, 0x3f, 0x34, 0x7d, 0xed, 0xce, 0xc0, 0xe5, 0xee, 0xcb, 0x8f, 0x3e, 0x85, 0x29, 0xe2, 0x75,
	0x72, 0x4d, 0xda, 0xb5, 0x81, 0xf2, 0x12, 0xf4, 0xc8, 0x80, 0x25, 0xe2, 0xf3, 0x93, 0x49, 0x82,
	0x43, 0xd3, 0x33, 0x6b, 0xf8, 0x6b, 0x7c, 0x56, 0x27, 0xe4, 0x05, 0xd5, 0xde, 0x1e, 0x28, 0xa9,
	0x07, 0x27, 0x7a, 0x00, 0x73, 0x7e, 0xe0, 0x90, 0xc0, 0x61, 0xed, 0x6d, 0xd7, 0xa4, 0x54, 0x84,
	0xdb, 0x37, 0xa2, 0xdc, 0x40, 0x37, 0x52, 0xb8, 0x74, 0x01, 0x79, 0xd9, 0x56, 0x46, 0x2d, 0xee,
	0xd2, 0x71, 0x70, 0xe4, 0xd2, 0xf1, 0x06, 0x32, 0xa0, 0x20, 0x7e, 0xec, 0x7b, 0x0e, 0xd3, 0x5e,
	0x4f, 0x67, 0xb1, 0x2a, 0x21, 0x4a, 0xdd, 0x67, 0xed, 0xbf, 0xfe, 0xed, 0xd6, 0x82, 0xa0, 0x3f,
	0xe5, 0xfe, 0xe4, 0x3b, 0x7c, 0x35, 0x71, 0xc3, 0x67, 0x6d, 0x03, 0x3a, 0x50, 0x74, 0x1b, 0xf2,
	0xd4, 0xa6, 0xda, 0xcd, 0xb4, 0x83, 0x58, 0xdd, 0xa9, 0xaa, 0xce, 0x39, 0x3e, 0x4c, 0xa7, 0xdc,
	0x1a, 0x9c, 0x4e, 0x59, 0x87, 0x71, 0x16, 0x98, 0x16, 0x0e, 0xb4, 0x37, 0x14, 0x71, 0x24, 0xf3,
	0x44, 0xc0, 0xc3, 0x24, 0x9b, 0xa4, 0x42, 0x1b, 0x30, 0xde, 0xa4, 0xf8, 0x70, 0xbb, 0xa2, 0xbd,
	0x39, 0x70, 0xdd, 0x15, 0x25, 0x5a, 0x07, 0x14, 0xe0, 0x06, 0x61, 0xb8, 0xe2, 0xb8, 0x84, 0x95,
	0x6d, 0x9b, 0x5b, 0x31, 0xed, 0x81, 0x38, 0xb8, 0x19, 0x18, 0x3e, 0x26, 0x71, 0xf3, 0x6d, 0xed,
	0x51, 0x7a, 0x4c, 0xfb, 0x02, 0x1e, 0x8e, 0x49, 0x52, 0x71, 0x0f, 0xc5, 0xe7, 0xfc, 0xdb, 0x38,
	0x60, 0x95, 0x80, 0xb4, 0x1c, 0x1b, 0x07, 0xda, 0x87, 0xd2, 0x43, 0xe9, 0x42, 0xa0, 0x15, 0x28,
	0xfc, 0x70, 0xc1, 0x94, 0xf6, 0xfa, 0x48, 0xa6, 0x5e, 0x23, 0x80, 0x58, 0x60, 0x46, 0xb5, 0xc7,
	0x5d, 0x0b, 0x7c, 0xd2, 0x59, 0x60, 0x46, 0xd1, 0x32, 0x0f, 0x83, 0x5b, 0x0e, 0xe5, 0x26, 0xf0,
	0x63, 0x99, 0xba, 0x0c, 0xdb, 0x68, 0x0b, 0x66, 0x1a, 0xdc, 0x93, 0x39, 0x64, 0x2e, 0xe5, 0x3d,
	0x53, 0xed, 0x93, 0x81, 0x4b, 0x95, 0xe2, 0x10, 0xf9, 0x61, 0x33, 0x5c, 0xa9, 0x27, 0x2a, 0x3f,
	0x1c, 0x02, 0x78, 0x0f, 0xf8, 0x25, 0xc3, 0x81, 0x67, 0xba, 0x72, 0x41, 0xb4, 0x4f, 0x07, 0xf7,
	0x90, 0xe4, 0x40, 0x9f, 0x87, 0xce, 0x69, 0xa8, 0x85, 0x3e, 0x1f, 0x28, 0x22, 0xc9, 0xc0, 0x75,
	0xa3, 0x65, 0x8a, 0x3b, 0x53, 0x96, 0xba, 0x51, 0xb6, 0xf4, 0x77, 0xa1, 0x10, 0xad, 0x16, 0x5a,
	0x85, 0xa2, 0xf2, 0xef, 0x78, 0xd0, 0xa3, 0x1e, 0x00, 0xe2, 0x20, 0xdd, 0x80, 0xa9, 0xf8, 0xae,
	0x8a, 0xc9, 0x09, 0xaf, 0xa9, 0xec, 0x99, 0x6e, 0x9b, 0x3a, 0x74, 0x08, 0x3f, 0x2b, 0xc5, 0xa1,
	0xdf, 0x83, 0xf9, 0x0c, 0xb5, 0xce, 0x3d, 0x47, 0x57, 0x64, 0x9b, 0xa5, 0x37, 0x29, 0x1b, 0xfa,
	0x3f, 0xcc, 0xc2, 0x42, 0x96, 0xdb, 0xf5, 0x47, 0x95, 0x94, 0xe0, 0xdb, 0xdd, 0xa4, 0x8c, 0x34,
	0x94, 0xf7, 0xad, 0x7c, 0xa4, 0xfe, 0xdb, 0x1d, 0x67, 0x88, 0x3b, 0xbe, 0x70, 0xe9, 0xb4, 0x46,
	0x71, 0x88, 0xb4, 0xc6, 0x56, 0x94, 0xd6, 0x98, 0x15, 0xfe, 0xca, 0xdd, 0xfe, 0x5e, 0x71, 0x66,
	0x5e, 0xe3, 0x0e, 0xcc, 0xb8, 0xc4, 0xb4, 0xb7, 0x4c, 0xd7, 0xf4, 0x2c, 0x1c, 0xec, 0x57, 0x44,
	0x72, 0xbe, 0x60, 0xa4, 0xa0, 0xe8, 0x31, 0x68, 0x71, 0x48, 0x55, 0xb8, 0x4f, 0x86, 0xe9, 0xd5,
	0x44, 0x46, 0x9e, 0x1b, 0xca, 0x9e, 0xf8, 0x28, 0x77, 0xf2, 0x4e, 0x9f, 0xdc, 0xc9, 0xfc, 0xab,
	0xe7, 0x4e, 0x16, 0x7e, 0xf9, 0xdc, 0xc9, 0xe2, 0x1f, 0x22, 0x77, 0xb2, 0xf4, 0x8b, 0xe6, 0x4e,
	0xae, 0x0d, 0x91, 0x3b, 0xb9, 0x03, 0x53, 0x01, 0xf6, 0x5d, 0xc7, 0x32, 0xb7, 0x45, 0xc4, 0xa9,
	0xf1, 0xbb, 0x23, 0xd7, 0x38, 0x0e, 0x47, 0x1f, 0xc5, 0x73, 0x2c, 0xd7, 0x07, 0x2f, 0x6f, 0xbf,
	0x3c, 0xcb, 0x8d, 0x57, 0xcf, 0xb3, 0xac, 0x5c, 0x3d, 0xcf, 0xf2, 0x7a, 0x2c, 0xcf, 0xf2, 0x48,
	0xe5, 0x59, 0xa4, 0x4f, 0xa0, 0xf7, 0xba, 0x34, 0xdf, 0xb5, 0x7c, 0x2f, 0x91, 0x72, 0xc9, 0xc8,
	0x99, 0xdc, 0xfa, 0xe5, 0x72, 0x26, 0xab, 0x57, 0xcc, 0x99, 0x6c, 0xc2, 0x62, 0x68, 0xa8, 0x4e,
	0x02, 0xf3, 0xfc, 0xdc, 0xb1, 0x94, 0xa5, 0xd6, 0xc5, 0x94, 0xb3, 0x91, 0xe9, 0xf4, 0xd1, 0x9b,
	0x97, 0x4c, 0x1f, 0x7d, 0x0c, 0x53, 0x2a, 0xb6, 0x16, 0xa7, 0x4b, 0x7b, 0xab, 0x7f, 0x86, 0x25,
	0x41, 0xdc, 0x33, 0x4d, 0x73, 0xfb, 0x2a, 0x69, 0x9a, 0xae, 0x94, 0xd1, 0x9d, 0x4b, 0xa5, 0x8c,
	0x12, 0x59, 0x9e, 0x77, 0x5f, 0x39, 0xcb, 0xb3, 0x3e, 0x7c, 0x96, 0xe7, 0xfe, 0x1f, 0x2e, 0xcb,
	0x53, 0x07, 0xad, 0xd7, 0xd1, 0xbe, 0xe2, 0x0b, 0xd8, 0x12, 0x8c, 0xd3, 0xe6, 0xf9, 0xb9, 0xf3,
	0x52, 0x75, 0xa6, 0x5a, 0xfa, 0x7f, 0xe4, 0xa0, 0x70, 0xb8, 0x53, 0x51, 0xb2, 0x55, 0x38, 0x9c,
	0xeb, 0x84, 0xc3, 0x25, 0xe9, 0x66, 0xab, 0x77, 0x4c, 0xee, 0x4e, 0x77, 0x87, 0xb2, 0xf9, 0xcc,
	0x50, 0x56, 0x87, 0xa9, 0x86, 0xed, 0x77, 0xa8, 0xe4, 0x63, 0x66, 0x02, 0x96, 0x7c, 0x26, 0x1e,
	0x1b, 0xea, 0x99, 0x38, 0x36, 0xfd, 0xf1, 0xe1, 0x5f, 0x7b, 0xfe, 0x33, 0x07, 0xa8, 0x3b, 0xe4,
	0xbc, 0xe2, 0x5a, 0xae, 0x42, 0x51, 0x3d, 0xfd, 0x0b, 0xd7, 0x50, 0xae, 0x4d, 0x1c, 0xc4, 0xc3,
	0x81, 0x9a, 0x70, 0xce, 0x76, 0x48, 0xc3, 0x74, 0xbc, 0xaa, 0x5c, 0x79, 0xb9, 0x4e, 0x19, 0x18,
	0xf4, 0x15, 0x20, 0xc7, 0x13, 0xa5, 0x0a, 0xbb, 0x5e, 0x8b, 0xb4, 0xf7, 0x1c, 0x97, 0xbb, 0xab,
	0xa3, 0x03, 0x87, 0x94, 0xc1, 0xa5, 0xff, 0x65, 0x0e, 0x6e, 0x1c, 0x37, 0xd9, 0x19, 0x69, 0x7a,
	0x76, 0x42, 0x85, 0xa8, 0x39, 0x7f, 0x0a, 0xa3, 0x0d, 0x62, 0xcb, 0x61, 0xcf, 0xc4, 0x3d, 0x90,
	0x3e, 0x4c, 0xeb, 0x87, 0xc4, 0xc6, 0x86, 0xe0, 0xd3, 0xd7, 0x60, 0x94, 0xb7, 0xd0, 0x34, 0x14,
	0xca, 0x07, 0x07, 0xc7, 0x5f, 0x9f, 0x96, 0x8f, 0xbe, 0x2d, 0xbd, 0x86, 0xe6, 0x60, 0xda, 0xd8,
	0xfd, 0x62, 0xbf, 0x7a, 0x62, 0x7c, 0x7b, 0x7a, 0x7c, 0x74, 0xf0, 0x6d, 0x29, 0xa7, 0xff, 0x34,
	0x0d, 0x45, 0x11, 0xf5, 0xbc, 0xd2, 0x6a, 0x67, 0xb9, 0xa8, 0x23, 0xaf, 0xea, 0xa2, 0xf6, 0x70,
	0x3f, 0xd3, 0x6e, 0xec, 0x68, 0x86, 0x1b, 0x9b, 0x36, 0xc5, 0x63, 0x3d, 0x4c, 0x71, 0xf4, 0x8a,
	0x3f, 0x1e, 0x7f, 0xc5, 0x7f, 0x0b, 0xa6, 0x45, 0x98, 0x59, 0x35, 0x1b, 0x3e, 0xb7, 0x0d, 0xe2,
	0x35, 0x2c, 0x67, 0x24, 0x81, 0xc9, 0xa7, 0x92, 0xc2, 0xd0, 0x4f, 0x25, 0x6b, 0x30, 0x2b, 0x95,
	0x65, 0xe7, 0xd6, 0x81, 0x2a, 0x9a, 0x49, 0x82, 0x43, 0x3f, 0xbb, 0x78, 0x15, 0x3f, 0x3b, 0xed,
	0x08, 0x4e, 0x5d, 0xd6, 0x11, 0xb4, 0xe0, 0xd6, 0x0b, 0x8c, 0x7d, 0xd3, 0x75, 0x5a, 0x7c, 0x45,
	0xb9, 0x1a, 0x15, 0x37, 0xd2, 0x93, 0x2a, 0xb8, 0x5c, 0xc3, 0x51, 0x45, 0x4c, 0x5a, 0xe6, 0x8e,
	0xaa, 0xcc, 0x32, 0x06, 0x49, 0x40, 0xdb, 0x50, 0xb2, 0xb1, 0xef, 0x92, 0x76, 0x03, 0x7b, 0x4c,
	0xea, 0x61, 0x55, 0x33, 0xd3, 0xd3, 0xd2, 0x74, 0x31, 0xf0, 0x7d, 0xf0, 0x55, 0xf9, 0x02, 0x55,
	0xe9, 0xb8, 0x9e, 0xdc, 0x1d, 0x4a, 0x6e, 0xa3, 0xac, 0x28, 0xad, 0x34, 0xb8, 0x92, 0xa5, 0x43,
	0x1c, 0xcb, 0x3d, 0x2c, 0x0c, 0x9d, 0x7b, 0x50, 0xf1, 0xc7, 0xe2, 0x10, 0xf1, 0x47, 0x86, 0x43,
	0xa4, 0xfd, 0x72, 0x0e, 0xd1, 0xf5, 0x2b, 0x3f, 0x22, 0x25, 0x5c, 0x9b, 0xe5, 0x4b, 0xba, 0x36,
	0x75, 0x78, 0x43, 0xea, 0x8a, 0x0a, 0xa7, 0xb4, 0x88, 0x5b, 0xf5, 0x1c, 0xee, 0x75, 0xd7, 0xf6,
	0x48, 0x10, 0xea, 0x34, 0xe5, 0x89, 0xf6, 0x5b, 0xce, 0xc1, 0x42, 0xd0, 0x39, 0xac, 0xf6, 0x24,
	0xda, 0xf7, 0x64, 0x47, 0xaf, 0x0f, 0xec, 0x68, 0xa0, 0x8c, 0x8c, 0x48, 0xe9, 0xe6, 0xe5, 0x23,
	0xa5, 0x6c, 0x8f, 0xfc, 0xf6, 0xe5, 0x3d, 0xf2, 0xcf, 0x60, 0x4a, 0x1e, 0x50, 0x19, 0x22, 0x2a,
	0x17, 0xfa, 0x46, 0x2c, 0x5e, 0xe9, 0xe8, 0x78, 0x15, 0x45, 0x26, 0x18, 0xd0, 0x87, 0x70, 0xed,
	0x87, 0x8b, 0x17, 0x94, 0xab, 0x2d, 0xb7, 0x85, 0x83, 0xdd, 0x97, 0x2c, 0x30, 0xb9, 0x47, 0xb6,
	0x5d, 0x16, 0x3e, 0x74, 0xc1, 0xe8, 0x85, 0x16, 0xf5, 0x93, 0x6e, 0xb3, 0xe6, 0x78, 0x54, 0x7b,
	0x43, 0x84, 0xac, 0x61, 0x33, 0xf4, 0x54, 0xf4, 0xae, 0xfa, 0xaa, 0x37, 0x07, 0x26, 0x04, 0xf5,
	0x9f, 0xf2, 0x50, 0xf8, 0xb2, 0x7a, 0xf8, 0x4a, 0x56, 0x69, 0x19, 0x26, 0xeb, 0xb4, 0xf1, 0x74,
	0xf7, 0xe9, 0xfe, 0x8e, 0x72, 0x00, 0xa2, 0x36, 0xf7, 0x90, 0xea, 0xb4, 0x51, 0x11, 0x23, 0xdd,
	0x17, 0x26, 0x40, 0x79, 0x48, 0x49, 0x28, 0xb7, 0x36, 0x75, 0xda, 0xa8, 0xba, 0x44, 0xaa, 0x9b,
	0xd0, 0x43, 0x8a, 0xc3, 0xd0, 0x5d, 0x28, 0xb5, 0xc4, 0xfb, 0x90, 0xeb, 0x60, 0x8f, 0x49, 0x69,
	0xb2, 0xd6, 0xb2, 0x0b, 0x8e, 0x56, 0xa0, 0x20, 0x60, 0x65, 0xdb, 0x8e, 0x2a, 0x2e, 0x23, 0x00,
	0xb7, 0x3c, 0xb2, 0xd1, 0x64, 0xf5, 0x8a, 0xc9, 0xea, 0xaa, 0xe8, 0x32, 0x09, 0x4c, 0x50, 0x19,
	0xc4, 0x0d, 0xab, 0x2e, 0x93, 0xc0, 0x68, 0x54, 0x1c, 0xf0, 0xd5, 0x05, 0x13, 0xe2, 0x0a, 0xb1,
	0x51, 0xc5, 0xe0, 0xdc, 0x28, 0x09, 0x98, 0x8c, 0x1e, 0x05, 0xa9, 0x32, 0x4a, 0x29, 0xb0, 0xfe,
	0x4f, 0x39, 0x40, 0xe2, 0x2c, 0x29, 0xdf, 0x57, 0x6d, 0x10, 0x77, 0x38, 0x25, 0x20, 0x4c, 0xec,
	0xe4, 0x94, 0xc3, 0x99, 0x80, 0xa2, 0x67, 0xb0, 0xe8, 0x44, 0x8c, 0x8c, 0xab, 0x1a, 0x1c, 0x1c,
	0x76, 0x3c, 0x9d, 0x58, 0xdd, 0x55, 0x26, 0x99, 0x91, 0xcd, 0xcd, 0x77, 0x29, 0x44, 0xb8, 0x26,
	0xa5, 0x6a, 0x2f, 0x13, 0x30, 0x7d, 0x1f, 0xe6, 0xc4, 0xc0, 0x13, 0x8e, 0xd6, 0xd5, 0xea, 0x92,
	0x18, 0xcc, 0x9e, 0x60, 0x17, 0x37, 0x30, 0x0b, 0x5e, 0x49, 0x10, 0xba, 0x07, 0x23, 0xad, 0x0d,
	0xf5, 0x78, 0x19, 0xbb, 0xac, 0x91, 0xf0, 0xe7, 0x1b, 0x2a, 0x56, 0x1e, 0x69, 0x6d, 0xe8, 0x7f,
	0x9d, 0x87, 0xb9, 0x2e, 0xcc, 0x15, 0x3b, 0xfe, 0x06, 0xe6, 0x1a, 0x98, 0x99, 0xb6, 0xc9, 0xcc,
	0x53, 0xfc, 0xd2, 0xaa, 0x9b, 0x9e, 0x2a, 0x65, 0x2c, 0x6e, 0xdc, 0xcb, 0x1c, 0xc7, 0xa1, 0xa2,
	0xde, 0x55, 0xc4, 0x6a, 0x5c, 0xa5, 0x46, 0x0a, 0x8e, 0x76, 0x01, 0xfc, 0x80, 0x34, 0x30, 0xab,
	0xe3, 0x66, 0x98, 0x33, 0xbd, 0x9d, 0x29, 0xb2, 0x12, 0x91, 0x29, 0x61, 0x31, 0x46, 0xf4, 0x25,
	0x14, 0x29, 0x33, 0xad, 0x17, 0x76, 0xe0, 0xb4, 0x70, 0xa0, 0x96, 0xe8, 0x4e, 0xa6, 0x9c, 0x2a,
	0xa7, 0xdb, 0x11, 0x74, 0x4a, 0x50, 0x9c, 0x15, 0xfd, 0x19, 0xcc, 0x99, 0x96, 0x85, 0x29, 0x3d,
	0x75, 0x49, 0xed, 0xd4, 0xef, 0x94, 0x42, 0x17, 0x37, 0x1e, 0x64, 0xca, 0x2b, 0x0b, 0xea, 0x03,
	0x52, 0x93, 0x27, 0x45, 0xba, 0xec, 0x4a, 0xf2, 0xac, 0x99, 0x44, 0xea, 0x26, 0xbc, 0x31, 0x70,
	0x95, 0xd0, 0x27, 0x50, 0xbc, 0x30, 0x69, 0x63, 0x78, 0xcf, 0x38, 0x4e, 0xae, 0xff, 0x2e, 0x0f,
	0x37, 0xfa, 0x2c, 0xdb, 0x15, 0x4f, 0xc0, 0x2b, 0x8d, 0x09, 0xfd, 0x2a, 0xf4, 0x62, 0x4f, 0x49,
	0x0b, 0x07, 0x81, 0x63, 0x63, 0xb5, 0x45, 0x9b, 0x43, 0x6d, 0xf5, 0xba, 0xfc, 0x73, 0xac, 0x78,
	0x8d, 0x19, 0x2b, 0xd1, 0x5e, 0xfe, 0xe7, 0x1c, 0xcc, 0x24, 0x49, 0xd0, 0x43, 0x98, 0x48, 0x56,
	0x4d, 0xf4, 0xb4, 0x8f, 0x21, 0x1d, 0xfa, 0x8c, 0x2b, 0x25, 0x61, 0xad, 0xd5, 0x7b, 0xa0, 0x9a,
	0x65, 0x4f, 0xce, 0x14, 0x39, 0x2a, 0xc3, 0x2c, 0x51, 0x7e, 0x45, 0x28, 0x21, 0xdf, 0x5f, 0x42,
	0x9a, 0x5e, 0xff, 0xdb, 0x31, 0x58, 0xe9, 0x77, 0x56, 0xaf, 0xb8, 0x7b, 0x1f, 0x76, 0x5e, 0x92,
	0x07, 0xee, 0x9c, 0xf0, 0x3c, 0xa2, 0xa7, 0xe4, 0xc7, 0x00, 0x0d, 0xe2, 0x39, 0x8c, 0x70, 0x8f,
	0x6f, 0x88, 0xba, 0x89, 0x18, 0x35, 0x7a, 0x0c, 0x93, 0x8c, 0xf8, 0xc4, 0x25, 0xb5, 0xf6, 0xe0,
	0xc0, 0x57, 0x74, 0x1b, 0xd1, 0xa3, 0x1d, 0x98, 0xb5, 0x1d, 0xca, 0x47, 0x1f, 0xf9, 0x7b, 0x83,
	0x73, 0x03, 0x69, 0x16, 0xbe, 0xa5, 0xc9, 0xa3, 0xa2, 0x6e, 0x72, 0xef, 0x2d, 0x4d, 0x92, 0xa3,
	0x1f, 0x60, 0x31, 0xdc, 0xa2, 0xe8, 0x9e, 0x8b, 0x65, 0x9c, 0x10, 0x06, 0x68, 0x73, 0x38, 0x0d,
	0xb3, 0x9e, 0xe0, 0x35, 0xb2, 0x45, 0xa2, 0x3a, 0x2c, 0xa8, 0x03, 0x95, 0xec, 0x6a, 0xf2, 0x15,
	0xba, 0xca, 0x94, 0xa8, 0x6f, 0xc2, 0x74, 0xb2, 0xeb, 0x49, 0x18, 0x3d, 0x3a, 0x3e, 0xda, 0x2d,
	0xbd, 0xc6, 0x7f, 0xed, 0x3d, 0x3b, 0x38, 0x28, 0xe5, 0xd0, 0x2c, 0x14, 0x77, 0x0d, 0xe3, 0xd8,
	0xa8, 0xca, 0xd8, 0x7f, 0x44, 0xff, 0xfb, 0x1c, 0xdc, 0x19, 0x4e, 0xef, 0x5d, 0xf1, 0x94, 0x7e,
	0x01, 0x73, 0x2e, 0xa9, 0x7d, 0xed, 0x78, 0x36, 0xb9, 0x08, 0xa3, 0x42, 0x75, 0x5e, 0xfb, 0x84,
	0x8d, 0xdd, 0x3c, 0xfa, 0xae, 0xb2, 0xdd, 0x71, 0x07, 0x16, 0x3d, 0x80, 0x79, 0xda, 0x3c, 0xa3,
	0x56, 0xe0, 0x9c, 0x61, 0xbb, 0x53, 0xb9, 0x92, 0x13, 0x4e, 0x68, 0x16, 0x4a, 0xff, 0x6d, 0x0e,
	0x8a, 0xb1, 0xc4, 0x7d, 0xf4, 0x84, 0x92, 0x8b, 0x3d, 0xa1, 0x88, 0x32, 0xf4, 0x80, 0x89, 0x61,
	0x8e, 0x19, 0xe2, 0x37, 0x77, 0x24, 0x79, 0x70, 0x2c, 0x9e, 0x0e, 0xf3, 0x02, 0x1e, 0xb5, 0xd1,
	0x4d, 0x00, 0x59, 0x64, 0x2e, 0xb0, 0xa3, 0x02, 0x1b, 0x83, 0x70, 0x5e, 0x5f, 0x45, 0x11, 0xca,
	0x29, 0x8c, 0xda, 0xfa, 0x3f, 0x4e, 0x42, 0x31, 0xf6, 0x62, 0xcf, 0x65, 0x99, 0x4d, 0x46, 0x64,
	0xd9, 0x82, 0x72, 0x35, 0x63, 0x10, 0xee, 0xf8, 0xa9, 0x0c, 0x96, 0xcc, 0x4c, 0x29, 0x81, 0x49,
	0x20, 0x7a, 0x07, 0xe6, 0x2c, 0xd2, 0xf0, 0x89, 0xc7, 0x63, 0xe4, 0xf0, 0xc3, 0x16, 0xe9, 0x6a,
	0x76, 0x23, 0x3a, 0xef, 0x9c, 0xdb, 0x24, 0xc0, 0x3b, 0xcd, 0x86, 0xaf, 0x72, 0x19, 0x43, 0xbc,
	0x73, 0x86, 0x1c, 0x7c, 0x27, 0xd4, 0x57, 0x3c, 0x2a, 0x3a, 0x92, 0xf9, 0x6b, 0x59, 0xb1, 0x93,
	0x85, 0xe2, 0x0e, 0x67, 0x08, 0xae, 0xa8, 0xf7, 0x2e, 0x55, 0xc1, 0x93, 0x02, 0x77, 0x52, 0x34,
	0x33, 0xf1, 0x14, 0xcd, 0x1a, 0xcc, 0xaa, 0xb4, 0x5a, 0xc4, 0x5f, 0x52, 0x15, 0x40, 0x49, 0x70,
	0xe2, 0xeb, 0x1e, 0x94, 0xfa, 0xba, 0x27, 0xf9, 0x39, 0xcb, 0xfc, 0x65, 0x3e, 0x67, 0x41, 0x5b,
	0xb0, 0x12, 0x60, 0xd3, 0x76, 0x3c, 0x4c, 0xe9, 0xbe, 0xe7, 0x30, 0xc7, 0x74, 0x77, 0xb0, 0x6b,
	0xb6, 0xab, 0xd8, 0x22, 0x9e, 0x2d, 0xdf, 0xcd, 0xa6, 0x8d, 0xbe, 0x34, 0xe8, 0x11, 0x2c, 0x45,
	0xf8, 0x0a, 0x0e, 0x1c, 0x62, 0x87, 0xdc, 0x8b, 0x82, 0xbb, 0x07, 0x16, 0x7d, 0x02, 0xd7, 0x23,
	0xcc, 0x9e, 0xe9, 0xb8, 0xcd, 0x00, 0x9f, 0xd4, 0x03, 0x4c, 0xeb, 0xc4, 0xb5, 0x45, 0x19, 0xcf,
	0xb4, 0xd1, 0x9b, 0x80, 0x9f, 0x32, 0xca, 0x4c, 0xd6, 0x14, 0x0f, 0x07, 0xa2, 0x02, 0x66, 0xda,
	0x88, 0x41, 0x92, 0x89, 0x2d, 0xed, 0x12, 0x89, 0xad, 0xb0, 0x84, 0xe3, 0xba, 0xd0, 0x6f, 0xa5,
	0x0e, 0x8f, 0x84, 0xc7, 0x8a, 0x37, 0x16, 0xd4, 0x2e, 0x87, 0x7a, 0x5d, 0x9e, 0x97, 0x15, 0xb1,
	0x3d, 0x99, 0x38, 0x3e, 0x28, 0xd7, 0x39, 0xc7, 0x56, 0xdb, 0x72, 0xf1, 0xc0, 0x2c, 0x4f, 0x44,
	0x89, 0xea, 0x70, 0x8b, 0xcf, 0xb9, 0xec, 0x8b, 0xa4, 0x1f, 0xd7, 0x25, 0xcf, 0x3c, 0xe6, 0xb8,
	0xe2, 0xd2, 0x55, 0x99, 0x19, 0xb0, 0x30, 0xda, 0x1e, 0x64, 0xc8, 0x06, 0x89, 0xe1, 0x77, 0x20,
	0x3c, 0x7a, 0xf1, 0x3b, 0x70, 0x47, 0xde, 0x81, 0x0c, 0x14, 0x5f, 0x06, 0x05, 0x4e, 0x2e, 0x83,
	0x2c, 0xa5, 0xca, 0xc4, 0xe9, 0xdf, 0xc3, 0x6c, 0xaa, 0x62, 0xa7, 0x73, 0x41, 0x72, 0xf1, 0x0b,
	0xf2, 0xfe, 0x70, 0x59, 0xfb, 0xd4, 0x26, 0xea, 0xdb, 0x70, 0xad, 0xc7, 0xd7, 0x13, 0x3c, 0x9a,
	0xb7, 0xfc, 0x66, 0xf8, 0xee, 0x60, 0xf9, 0x4d, 0x59, 0x95, 0xd6, 0x20, 0x41, 0x3b, 0x7c, 0xaf,
	0x90, 0x2d, 0xfd, 0x53, 0x28, 0x44, 0x85, 0x40, 0xe8, 0x21, 0x8c, 0x31, 0xf2, 0x02, 0x7b, 0x03,
	0x0c, 0xb5, 0x18, 0x88, 0xa4, 0xd4, 0x7f, 0x0d, 0x53, 0xf1, 0x67, 0x4c, 0x1e, 0x33, 0x8b, 0xba,
	0x14, 0x11, 0x97, 0xca, 0xfe, 0x3b, 0x80, 0x48, 0x89, 0x8f, 0xc4, 0x94, 0x38, 0x3f, 0xe2, 0x42,
	0x82, 0x48, 0xfe, 0xcb, 0x68, 0x30, 0x06, 0xd1, 0xff, 0x26, 0x07, 0xd3, 0x2a, 0x24, 0x55, 0xc3,
	0xbc, 0xfa, 0xf7, 0x2f, 0x3c, 0xf8, 0x0c, 0x9f, 0x03, 0x2b, 0xa1, 0xe5, 0x98, 0x36, 0x12, 0xb0,
	0x68, 0x90, 0xf9, 0xa4, 0xa5, 0x49, 0x57, 0xab, 0xeb, 0xbf, 0x1b, 0x83, 0xc5, 0xcc, 0xe2, 0x35,
	0xf4, 0x0d, 0x5c, 0x97, 0x5a, 0xb7, 0x53, 0x2d, 0xb7, 0xd5, 0x56, 0x45, 0x99, 0x43, 0x78, 0xef,
	0xbd, 0x99, 0xd1, 0x3e, 0xcc, 0x7b, 0xb8, 0x85, 0x55, 0x87, 0x51, 0xca, 0xb8, 0xd8, 0xff, 0xc9,
	0x2f, 0x8b, 0x47, 0x3c, 0x42, 0xba, 0x17, 0x66, 0x9b, 0xa6, 0x64, 0x4d, 0x0d, 0x7a, 0x84, 0xcc,
	0x60, 0x42, 0x07, 0x30, 0x1f, 0xe0, 0x8b, 0xc0, 0x61, 0xb8, 0xec, 0xfb, 0x5f, 0x9e, 0x9c, 0x54,
	0x2a, 0x01, 0x39, 0xc3, 0xea, 0x33, 0xc7, 0x7e, 0x73, 0xcd, 0x62, 0xe3, 0xb3, 0x94, 0x0f, 0x88,
	0x38, 0x91, 0xb4, 0x1b, 0x50, 0x31, 0x99, 0xc5, 0xc3, 0x9d, 0x50, 0x72, 0x96, 0x98, 0xdf, 0x80,
	0xbc, 0x6e, 0x8a, 0x5c, 0xa6, 0x2b, 0xd4, 0x63, 0xe6, 0x33, 0xe3, 0x40, 0xa8, 0x6c, 0x91, 0xae,
	0xe8, 0xc0, 0xf8, 0x05, 0x66, 0xea, 0x9d, 0x93, 0xaa, 0x32, 0xc5, 0xde, 0x0a, 0x2f, 0xa2, 0x44,
	0x77, 0xa3, 0x5a, 0xde, 0x93, 0x88, 0x5b, 0x93, 0x05, 0xaf, 0x69, 0x38, 0x3a, 0x02, 0xd4, 0xa4,
	0xf8, 0x00, 0xd7, 0x4c, 0xab, 0x1d, 0x8e, 0x8d, 0x0e, 0xe9, 0xd8, 0x67, 0x70, 0xea, 0x7f, 0x31,
	0x02, 0x53, 0xf1, 0x6a, 0x3d, 0xf4, 0x01, 0x4c, 0xf0, 0x68, 0xd8, 0x26, 0xb5, 0xee, 0x4a, 0x77,
	0x49, 0xb8, 0x23, 0xd1, 0x61, 0xbd, 0xab, 0xa2, 0x46, 0x4f, 0xb8, 0xb6, 0xaf, 0xd5, 0x19, 0x65,
	0xd8, 0x57, 0x87, 0xfb, 0x56, 0x9a, 0xf5, 0x80, 0x13, 0x54, 0x19, 0xf6, 0x15, 0x73, 0x87, 0x03,
	0x6d, 0xc2, 0xf8, 0x8f, 0x8e, 0xff, 0xc2, 0x09, 0xeb, 0xc2, 0x57, 0xd2, 0xbc, 0xdf, 0x09, 0x6c,
	0x58, 0xbf, 0x27, 0x69, 0xd1, 0x76, 0x32, 0xe5, 0x30, 0x9a, 0xfe, 0xac, 0x4c, 0xb2, 0x56, 0x3b,
	0x24, 0x19, 0xd9, 0x06, 0xfd, 0x3e, 0xcc, 0x67, 0xcc, 0x0c, 0x69, 0x30, 0x61, 0xaa, 0x32, 0x3a,
	0xa9, 0xc0, 0xc2, 0xa6, 0x5e, 0x85, 0xc5, 0xcc, 0xf9, 0xf4, 0x66, 0x41, 0xab, 0x50, 0x94, 0x69,
	0x88, 0x13, 0xa1, 0x58, 0xd5, 0xdb, 0x66, 0x0c, 0xa4, 0xaf, 0x03, 0xea, 0x9e, 0x68, 0x9f, 0x41,
	0xfc, 0x4f, 0x0e, 0xae, 0xf5, 0x98, 0x1e, 0x7a, 0x00, 0x63, 0x36, 0x3e, 0x6b, 0xd6, 0x86, 0x70,
	0xfc, 0x25, 0x21, 0xda, 0x84, 0xc5, 0x86, 0xf9, 0xf2, 0xa8, 0xd9, 0x38, 0xc3, 0xc1, 0xf1, 0x79,
	0x99, 0xb1, 0xc0, 0x39, 0x6b, 0xf2, 0x83, 0x28, 0x35, 0x63, 0x36, 0x92, 0x3b, 0x43, 0x71, 0x44,
	0xec, 0x8e, 0xca, 0x57, 0xc0, 0x1e, 0x58, 0xf4, 0x18, 0xb4, 0x18, 0xe6, 0x10, 0x53, 0x6a, 0xd6,
	0xc2, 0x2f, 0x6c, 0xe5, 0xdb, 0x60, 0x4f, 0xbc, 0xfe, 0xfb, 0x1c, 0xc0, 0x96, 0x49, 0x43, 0x23,
	0xf0, 0x15, 0x20, 0xe5, 0xd9, 0x1a, 0x3b, 0x9d, 0xeb, 0x33, 0x78, 0xde, 0x19, 0x5c, 0x32, 0x49,
	0x1b, 0x7e, 0x6b, 0xc0, 0x2f, 0xf9, 0x48, 0x98, 0xa4, 0x8d, 0x01, 0x51, 0x05, 0x16, 0x25, 0xaf,
	0xa8, 0x3d, 0x94, 0xc3, 0xd8, 0x36, 0x76, 0xe8, 0x10, 0x81, 0x79, 0x36, 0xa3, 0xfe, 0x3d, 0x20,
	0x59, 0xc7, 0x68, 0x88, 0x8a, 0x56, 0x35, 0xb3, 0xb4, 0xc6, 0xc9, 0x65, 0x68, 0x9c, 0xb7, 0x60,
	0x3a, 0x6a, 0x0b, 0x53, 0xab, 0x46, 0x9c, 0x00, 0xea, 0x7f, 0x3e, 0x0e, 0xe3, 0x62, 0x00, 0x14,
	0xdd, 0x86, 0xbc, 0xe5, 0x39, 0xea, 0x7e, 0xce, 0x27, 0xbe, 0x58, 0x0f, 0x8b, 0x54, 0x2d, 0xcf,
	0x41, 0x9b, 0x30, 0xa9, 0x32, 0x32, 0xa1, 0x27, 0x12, 0xab, 0xcf, 0x48, 0x7e, 0x27, 0x63, 0x44,
	0x94, 0x68, 0x1d, 0xc6, 0xe5, 0x23, 0xbc, 0x4a, 0x13, 0x2c, 0xa5, 0x4b, 0xe5, 0xc3, 0xdb, 0x2b,
	0xa9, 0x44, 0xa9, 0x16, 0x0f, 0x11, 0x55, 0x55, 0xe0, 0x62, 0xe6, 0xd3, 0x87, 0x21, 0x69, 0xd0,
	0x07, 0x5c, 0xb9, 0xaa, 0xc0, 0x57, 0x29, 0xd7, 0xeb, 0x19, 0xe1, 0x78, 0xa8, 0x59, 0x22, 0x5a,
	0xf4, 0x35, 0x2c, 0xd1, 0xa4, 0x79, 0x56, 0x65, 0xdc, 0xea, 0x35, 0x34, 0xa6, 0xa5, 0x32, 0xcd,
	0xb8, 0xd1, 0x83, 0x1d, 0x3d, 0x80, 0x82, 0xfc, 0x32, 0x87, 0xaf, 0xe8, 0x7c, 0xef, 0x15, 0x9d,
	0x14, 0x54, 0xdb, 0x9e, 0x93, 0xa8, 0xfd, 0x5d, 0x4c, 0xd5, 0xfe, 0xae, 0x40, 0x81, 0x5c, 0x84,
	0x5f, 0x6e, 0x4b, 0xeb, 0xd2, 0x01, 0xa0, 0x47, 0x00, 0x0d, 0x4c, 0xd5, 0xa7, 0x38, 0xca, 0x99,
	0xee, 0xf5, 0x18, 0x13, 0xa3, 0x44, 0x6b, 0x30, 0x7a, 0x66, 0x52, 0xac, 0x3c, 0xe6, 0xd8, 0x87,
	0x3d, 0x9d, 0x2b, 0x64, 0x08, 0x0a, 0xf4, 0x39, 0x4c, 0x39, 0xb1, 0x43, 0xa8, 0xca, 0xf6, 0x57,
	0xd2, 0x05, 0xd4, 0xf1, 0x23, 0x6a, 0x24, 0x38, 0xf8, 0x81, 0x0d, 0x67, 0x73, 0x62, 0xd6, 0xb8,
	0x53, 0xcc, 0x6d, 0x58, 0x02, 0xc6, 0x83, 0xc0, 0xe8, 0xcb, 0x13, 0xb5, 0x10, 0x6b, 0x32, 0x08,
	0x4c, 0x81, 0xf9, 0x49, 0xad, 0xd3, 0x86, 0x66, 0xa7, 0xd7, 0x35, 0x7a, 0x61, 0x32, 0x38, 0x9e,
	0x93, 0x35, 0x6c, 0x5f, 0xc3, 0x69, 0xb2, 0xa8, 0xf8, 0xc6, 0xe0, 0x78, 0xfd, 0x57, 0x30, 0x9d,
	0xf8, 0x78, 0xf0, 0x17, 0x2e, 0xf7, 0xf9, 0xab, 0x1c, 0x14, 0x63, 0xaf, 0xb2, 0x91, 0x9f, 0x98,
	0x93, 0x1f, 0xc6, 0x8b, 0x6a, 0xbb, 0xf7, 0x60, 0xdc, 0xf1, 0xd8, 0x73, 0xd3, 0x55, 0xb7, 0xef,
	0x46, 0x57, 0x87, 0xfb, 0x1e, 0x7b, 0x6f, 0x43, 0x3d, 0x42, 0x4b, 0x52, 0x6e, 0x16, 0x29, 0x0b,
	0x38, 0x53, 0x68, 0x16, 0x33, 0xfc, 0x09, 0xc7, 0xab, 0x29, 0x2e, 0x49, 0x7b, 0xf7, 0xab, 0x1e,
	0x4f, 0x36, 0x68, 0x16, 0x8a, 0xcf, 0x8e, 0xaa, 0x95, 0xdd, 0xed, 0xfd, 0xbd, 0xfd, 0xdd, 0x9d,
	0xd2, 0x6b, 0xa8, 0x08, 0x13, 0x3b, 0xbb, 0x7b, 0xe5, 0x67, 0x07, 0x27, 0xa5, 0x1c, 0x02, 0x18,
	0xaf, 0x9e, 0x18, 0xfb, 0xdb, 0x27, 0xa5, 0x11, 0x34, 0x01, 0xf9, 0xe3, 0xbd, 0xbd, 0x52, 0xfe,
	0xee, 0xaf, 0xc3, 0x18, 0x91, 0xa3, 0xa5, 0xd9, 0x2d, 0xbd, 0x86, 0xa6, 0x63, 0xd6, 0xbe, 0x94,
	0xe3, 0x62, 0x94, 0x1f, 0x50, 0x1a, 0xe1, 0x9d, 0xc4, 0xcc, 0x6b, 0x29, 0x8f, 0xe6, 0x61, 0x96,
	0xf8, 0xd8, 0xdb, 0xc6, 0x1e, 0x6d, 0xd2, 0x72, 0x0d, 0x7b, 0xac, 0x34, 0x8a, 0x26, 0x61, 0xd4,
	0x23, 0x1e, 0x2e, 0x8d, 0x6d, 0x3d, 0xf9, 0x97, 0x9f, 0x6f, 0xe6, 0x7e, 0xff, 0xf3, 0xcd, 0xdc,
	0xbf, 0xff, 0x7c, 0x33, 0xf7, 0x9d, 0xfc, 0xdf, 0x35, 0xeb, 0x0e, 0x51, 0xff, 0xc4, 0x26, 0xfc,
	0x02, 0xe3, 0x7e, 0x8f, 0x7f, 0x6e, 0x73, 0x36, 0x2e, 0x96, 0xe2, 0xbd, 0xff, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0x77, 0x14, 0x53, 0xd8, 0xfe, 0x46, 0x00, 0x00,
}

func (m *ArchConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Arm64 != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Arm64))
		i--
		dAtA[i] = 0x20
	}
	if m.S390X != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.S390X))
		i--
		dAtA[i] = 0x18
	}
	if m.Ppc64Le != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Ppc64Le))
		i--
		dAtA[i] = 0x10
	}
	if m.Amd64 != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Amd64))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNIConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNIConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNIConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Privileged != nil {
		{
			size, err := m.Privileged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ResourceQuotas != nil {
		{
			size, err := m.ResourceQuotas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Taint != nil {
		{
			size, err := m.Taint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Chained != nil {
		{
			size, err := m.Chained.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Repair != nil {
		{
			size, err := m.Repair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.LogLevel) > 0 {
		i -= len(m.LogLevel)
		copy(dAtA[i:], m.LogLevel)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LogLevel)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.PspClusterRole) > 0 {
		i -= len(m.PspClusterRole)
		copy(dAtA[i:], m.PspClusterRole)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PspClusterRole)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PodAnnotations != nil {
		{
			size, err := m.PodAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ExcludeNamespaces) > 0 {
		for iNdEx := len(m.ExcludeNamespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExcludeNamespaces[iNdEx])
			copy(dAtA[i:], m.ExcludeNamespaces[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeNamespaces[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CniConfFileName) > 0 {
		i -= len(m.CniConfFileName)
		copy(dAtA[i:], m.CniConfFileName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CniConfFileName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CniConfDir) > 0 {
		i -= len(m.CniConfDir)
		copy(dAtA[i:], m.CniConfDir)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CniConfDir)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CniBinDir) > 0 {
		i -= len(m.CniBinDir)
		copy(dAtA[i:], m.CniBinDir)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CniBinDir)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PullPolicy) > 0 {
		i -= len(m.PullPolicy)
		copy(dAtA[i:], m.PullPolicy)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PullPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hub) > 0 {
		i -= len(m.Hub)
		copy(dAtA[i:], m.Hub)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNITaintConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNITaintConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNITaintConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNIRepairConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNIRepairConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNIRepairConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InitContainerName) > 0 {
		i -= len(m.InitContainerName)
		copy(dAtA[i:], m.InitContainerName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InitContainerName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.BrokenPodLabelValue) > 0 {
		i -= len(m.BrokenPodLabelValue)
		copy(dAtA[i:], m.BrokenPodLabelValue)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.BrokenPodLabelValue)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BrokenPodLabelKey) > 0 {
		i -= len(m.BrokenPodLabelKey)
		copy(dAtA[i:], m.BrokenPodLabelKey)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.BrokenPodLabelKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.DeletePods {
		i--
		if m.DeletePods {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.CreateEvents) > 0 {
		i -= len(m.CreateEvents)
		copy(dAtA[i:], m.CreateEvents)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CreateEvents)))
		i--
		dAtA[i] = 0x32
	}
	if m.LabelPods {
		i--
		if m.LabelPods {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hub) > 0 {
		i -= len(m.Hub)
		copy(dAtA[i:], m.Hub)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceQuotas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceQuotas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceQuotas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pods != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Pods))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPUTargetUtilizationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUTargetUtilizationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUTargetUtilizationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetAverageUtilization != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.TargetAverageUtilization))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Requests) > 0 {
		for k := range m.Requests {
			v := m.Requests[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintValuesTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Limits) > 0 {
		for k := range m.Limits {
			v := m.Limits[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintValuesTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServiceAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Annotations != nil {
		{
			size, err := m.Annotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefaultPodDisruptionBudgetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultPodDisruptionBudgetConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultPodDisruptionBudgetConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefaultResourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultResourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultResourcesConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Requests != nil {
		{
			size, err := m.Requests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EgressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressGatewayConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceAccount != nil {
		{
			size, err := m.ServiceAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InjectionTemplate) > 0 {
		i -= len(m.InjectionTemplate)
		copy(dAtA[i:], m.InjectionTemplate)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InjectionTemplate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.RunAsRoot != nil {
		{
			size, err := m.RunAsRoot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.AdditionalContainers) > 0 {
		for iNdEx := len(m.AdditionalContainers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdditionalContainers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.ConfigVolumes) > 0 {
		for iNdEx := len(m.ConfigVolumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConfigVolumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.RollingMaxUnavailable != nil {
		{
			size, err := m.RollingMaxUnavailable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.RollingMaxSurge != nil {
		{
			size, err := m.RollingMaxSurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Zvpn != nil {
		{
			size, err := m.Zvpn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ServiceAnnotations != nil {
		{
			size, err := m.ServiceAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SecretVolumes) > 0 {
		for iNdEx := len(m.SecretVolumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SecretVolumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.PodAntiAffinityTermLabelSelector) > 0 {
		for iNdEx := len(m.PodAntiAffinityTermLabelSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodAntiAffinityTermLabelSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.PodAntiAffinityLabelSelector) > 0 {
		for iNdEx := len(m.PodAntiAffinityLabelSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodAntiAffinityLabelSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.PodAnnotations != nil {
		{
			size, err := m.PodAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.NodeSelector != nil {
		{
			size, err := m.NodeSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintValuesTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Env != nil {
		{
			size, err := m.Env.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.AutoscaleMin != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
		i--
		dAtA[i] = 0x18
	}
	if m.AutoscaleMax != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
		i--
		dAtA[i] = 0x10
	}
	if m.AutoscaleEnabled != nil {
		{
			size, err := m.AutoscaleEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GatewaysConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewaysConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GatewaysConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IstioIngressgateway != nil {
		{
			size, err := m.IstioIngressgateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IstioEgressgateway != nil {
		{
			size, err := m.IstioEgressgateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CaName) > 0 {
		i -= len(m.CaName)
		copy(dAtA[i:], m.CaName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CaName)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x8a
	}
	if m.ConfigCluster != nil {
		{
			size, err := m.ConfigCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x82
	}
	if m.ExternalIstiod != nil {
		{
			size, err := m.ExternalIstiod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if len(m.CaAddress) > 0 {
		i -= len(m.CaAddress)
		copy(dAtA[i:], m.CaAddress)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CaAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	if m.MountMtlsCerts != nil {
		{
			size, err := m.MountMtlsCerts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	if m.Sts != nil {
		{
			size, err := m.Sts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	if len(m.JwtPolicy) > 0 {
		i -= len(m.JwtPolicy)
		copy(dAtA[i:], m.JwtPolicy)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.JwtPolicy)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if len(m.PilotCertProvider) > 0 {
		i -= len(m.PilotCertProvider)
		copy(dAtA[i:], m.PilotCertProvider)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PilotCertProvider)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	if len(m.DefaultTolerations) > 0 {
		for iNdEx := len(m.DefaultTolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DefaultTolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Istiod != nil {
		{
			size, err := m.Istiod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if len(m.MeshID) > 0 {
		i -= len(m.MeshID)
		copy(dAtA[i:], m.MeshID)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.MeshID)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if len(m.DefaultConfigVisibilitySettings) > 0 {
		for iNdEx := len(m.DefaultConfigVisibilitySettings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultConfigVisibilitySettings[iNdEx])
			copy(dAtA[i:], m.DefaultConfigVisibilitySettings[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.DefaultConfigVisibilitySettings[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ConfigRootNamespace) > 0 {
		i -= len(m.ConfigRootNamespace)
		copy(dAtA[i:], m.ConfigRootNamespace)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConfigRootNamespace)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.RemotePilotAddress) > 0 {
		i -= len(m.RemotePilotAddress)
		copy(dAtA[i:], m.RemotePilotAddress)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.RemotePilotAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if len(m.PodDNSSearchNamespaces) > 0 {
		for iNdEx := len(m.PodDNSSearchNamespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PodDNSSearchNamespaces[iNdEx])
			copy(dAtA[i:], m.PodDNSSearchNamespaces[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PodDNSSearchNamespaces[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xda
		}
	}
	if m.OperatorManageWebhooks != nil {
		{
			size, err := m.OperatorManageWebhooks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.OmitSidecarInjectorConfigMap != nil {
		{
			size, err := m.OmitSidecarInjectorConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if len(m.ImagePullSecrets) > 0 {
		for iNdEx := len(m.ImagePullSecrets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImagePullSecrets[iNdEx])
			copy(dAtA[i:], m.ImagePullSecrets[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ImagePullSecrets[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.LogAsJson != nil {
		{
			size, err := m.LogAsJson.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.UseMCP != nil {
		{
			size, err := m.UseMCP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Tracer != nil {
		{
			size, err := m.Tracer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Sds != nil {
		{
			size, err := m.Sds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ProxyInit != nil {
		{
			size, err := m.ProxyInit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.Proxy != nil {
		{
			size, err := m.Proxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.PriorityClassName) > 0 {
		i -= len(m.PriorityClassName)
		copy(dAtA[i:], m.PriorityClassName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PriorityClassName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.OneNamespace != nil {
		{
			size, err := m.OneNamespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.MultiCluster != nil {
		{
			size, err := m.MultiCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.MeshNetworks != nil {
		{
			size, err := m.MeshNetworks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Logging != nil {
		{
			size, err := m.Logging.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.IstioNamespace) > 0 {
		i -= len(m.IstioNamespace)
		copy(dAtA[i:], m.IstioNamespace)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IstioNamespace)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ImagePullPolicy) > 0 {
		i -= len(m.ImagePullPolicy)
		copy(dAtA[i:], m.ImagePullPolicy)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ImagePullPolicy)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Hub) > 0 {
		i -= len(m.Hub)
		copy(dAtA[i:], m.Hub)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i--
		dAtA[i] = 0x62
	}
	if m.DefaultResources != nil {
		{
			size, err := m.DefaultResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DefaultPodDisruptionBudget != nil {
		{
			size, err := m.DefaultPodDisruptionBudget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DefaultNodeSelector != nil {
		{
			size, err := m.DefaultNodeSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ConfigValidation != nil {
		{
			size, err := m.ConfigValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Arch != nil {
		{
			size, err := m.Arch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *STSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *STSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *STSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServicePort != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ServicePort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IstiodConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstiodConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IstiodConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnableAnalysis != nil {
		{
			size, err := m.EnableAnalysis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GlobalLoggingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalLoggingConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalLoggingConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressGatewayConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceAccount != nil {
		{
			size, err := m.ServiceAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	if len(m.InjectionTemplate) > 0 {
		i -= len(m.InjectionTemplate)
		copy(dAtA[i:], m.InjectionTemplate)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InjectionTemplate)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.RunAsRoot != nil {
		{
			size, err := m.RunAsRoot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if len(m.ConfigVolumes) > 0 {
		for iNdEx := len(m.ConfigVolumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConfigVolumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.AdditionalContainers) > 0 {
		for iNdEx := len(m.AdditionalContainers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdditionalContainers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.IngressPorts) > 0 {
		for iNdEx := len(m.IngressPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ExternalTrafficPolicy) > 0 {
		i -= len(m.ExternalTrafficPolicy)
		copy(dAtA[i:], m.ExternalTrafficPolicy)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExternalTrafficPolicy)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.RollingMaxUnavailable != nil {
		{
			size, err := m.RollingMaxUnavailable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.RollingMaxSurge != nil {
		{
			size, err := m.RollingMaxSurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Zvpn != nil {
		{
			size, err := m.Zvpn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.ServiceAnnotations != nil {
		{
			size, err := m.ServiceAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.SecretVolumes) > 0 {
		for iNdEx := len(m.SecretVolumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SecretVolumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.ReplicaCount != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.PodAntiAffinityTermLabelSelector) > 0 {
		for iNdEx := len(m.PodAntiAffinityTermLabelSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodAntiAffinityTermLabelSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.PodAntiAffinityLabelSelector) > 0 {
		for iNdEx := len(m.PodAntiAffinityLabelSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodAntiAffinityLabelSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.PodAnnotations != nil {
		{
			size, err := m.PodAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.NodeSelector != nil {
		{
			size, err := m.NodeSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for iNdEx := len(m.LoadBalancerSourceRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LoadBalancerSourceRanges[iNdEx])
			copy(dAtA[i:], m.LoadBalancerSourceRanges[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LoadBalancerSourceRanges[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.LoadBalancerIP) > 0 {
		i -= len(m.LoadBalancerIP)
		copy(dAtA[i:], m.LoadBalancerIP)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LoadBalancerIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintValuesTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.Env != nil {
		{
			size, err := m.Env.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CustomService != nil {
		{
			size, err := m.CustomService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.AutoscaleMin != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
		i--
		dAtA[i] = 0x18
	}
	if m.AutoscaleMax != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
		i--
		dAtA[i] = 0x10
	}
	if m.AutoscaleEnabled != nil {
		{
			size, err := m.AutoscaleEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngressGatewayZvpnConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayZvpnConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressGatewayZvpnConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Suffix) > 0 {
		i -= len(m.Suffix)
		copy(dAtA[i:], m.Suffix)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Suffix)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MDPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MDPConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MDPConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MdpNamespace) > 0 {
		i -= len(m.MdpNamespace)
		copy(dAtA[i:], m.MdpNamespace)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.MdpNamespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IstioNamespace) > 0 {
		i -= len(m.IstioNamespace)
		copy(dAtA[i:], m.IstioNamespace)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IstioNamespace)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hub) > 0 {
		i -= len(m.Hub)
		copy(dAtA[i:], m.Hub)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeEnvoyFilter != nil {
		{
			size, err := m.IncludeEnvoyFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.GlobalDomainSuffix) > 0 {
		i -= len(m.GlobalDomainSuffix)
		copy(dAtA[i:], m.GlobalDomainSuffix)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.GlobalDomainSuffix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutboundTrafficPolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutboundTrafficPolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutboundTrafficPolicyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *PilotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PilotConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceAnnotations != nil {
		{
			size, err := m.ServiceAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.PodLabels != nil {
		{
			size, err := m.PodLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Hub) > 0 {
		i -= len(m.Hub)
		copy(dAtA[i:], m.Hub)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.Plugins) > 0 {
		for iNdEx := len(m.Plugins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Plugins[iNdEx])
			copy(dAtA[i:], m.Plugins[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Plugins[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.JwksResolverExtraRootCA) > 0 {
		i -= len(m.JwksResolverExtraRootCA)
		copy(dAtA[i:], m.JwksResolverExtraRootCA)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.JwksResolverExtraRootCA)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.ConfigSource != nil {
		{
			size, err := m.ConfigSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.PodAnnotations != nil {
		{
			size, err := m.PodAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.EnableProtocolSniffingForInbound != nil {
		{
			size, err := m.EnableProtocolSniffingForInbound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.EnableProtocolSniffingForOutbound != nil {
		{
			size, err := m.EnableProtocolSniffingForOutbound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.RollingMaxUnavailable != nil {
		{
			size, err := m.RollingMaxUnavailable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.RollingMaxSurge != nil {
		{
			size, err := m.RollingMaxSurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Env != nil {
		{
			size, err := m.Env.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.UseMCP != nil {
		{
			size, err := m.UseMCP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ConfigMap != nil {
		{
			size, err := m.ConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.DeploymentLabels != nil {
		{
			size, err := m.DeploymentLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		{
			size, err := m.KeepaliveMaxServerConnectionAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.NodeSelector != nil {
		{
			size, err := m.NodeSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ConfigNamespace) > 0 {
		i -= len(m.ConfigNamespace)
		copy(dAtA[i:], m.ConfigNamespace)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConfigNamespace)))
		i--
		dAtA[i] = 0x52
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TraceSampling != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TraceSampling))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x32
	}
	if m.ReplicaCount != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AutoscaleMax != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoscaleMin != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
		i--
		dAtA[i] = 0x18
	}
	if m.AutoscaleEnabled != nil {
		{
			size, err := m.AutoscaleEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VaultSecretPath) > 0 {
		i -= len(m.VaultSecretPath)
		copy(dAtA[i:], m.VaultSecretPath)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultSecretPath)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.VaultAuthJwtPath) > 0 {
		i -= len(m.VaultAuthJwtPath)
		copy(dAtA[i:], m.VaultAuthJwtPath)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultAuthJwtPath)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.VaultAuthRole) > 0 {
		i -= len(m.VaultAuthRole)
		copy(dAtA[i:], m.VaultAuthRole)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultAuthRole)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.VaultAuthPath) > 0 {
		i -= len(m.VaultAuthPath)
		copy(dAtA[i:], m.VaultAuthPath)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultAuthPath)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VaultAddr) > 0 {
		i -= len(m.VaultAddr)
		copy(dAtA[i:], m.VaultAddr)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VaultClientImage) > 0 {
		i -= len(m.VaultClientImage)
		copy(dAtA[i:], m.VaultClientImage)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.VaultClientImage)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HsmSlotLabel) > 0 {
		i -= len(m.HsmSlotLabel)
		copy(dAtA[i:], m.HsmSlotLabel)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.HsmSlotLabel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HsmPluginImage) > 0 {
		i -= len(m.HsmPluginImage)
		copy(dAtA[i:], m.HsmPluginImage)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.HsmPluginImage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HsmKEKID) > 0 {
		i -= len(m.HsmKEKID)
		copy(dAtA[i:], m.HsmKEKID)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.HsmKEKID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PilotIngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotIngressConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PilotIngressConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IngressClass) > 0 {
		i -= len(m.IngressClass)
		copy(dAtA[i:], m.IngressClass)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IngressClass)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IngressControllerMode != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.IngressControllerMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.IngressService) > 0 {
		i -= len(m.IngressService)
		copy(dAtA[i:], m.IngressService)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IngressService)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PilotPolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotPolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PilotPolicyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V2 != nil {
		{
			size, err := m.V2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessLogPolicy != nil {
		{
			size, err := m.AccessLogPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MetadataExchange != nil {
		{
			size, err := m.MetadataExchange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Stackdriver != nil {
		{
			size, err := m.Stackdriver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Prometheus != nil {
		{
			size, err := m.Prometheus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2MetadataExchangeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2MetadataExchangeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2MetadataExchangeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WasmEnabled != nil {
		{
			size, err := m.WasmEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2PrometheusConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2PrometheusConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2PrometheusConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigOverride != nil {
		{
			size, err := m.ConfigOverride.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.WasmEnabled != nil {
		{
			size, err := m.WasmEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutboundSidecar != nil {
		{
			size, err := m.OutboundSidecar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InboundSidecar != nil {
		{
			size, err := m.InboundSidecar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Gateway != nil {
		{
			size, err := m.Gateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2StackDriverConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2StackDriverConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2StackDriverConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InboundAccessLogging != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.InboundAccessLogging))
		i--
		dAtA[i] = 0x40
	}
	if m.OutboundAccessLogging != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.OutboundAccessLogging))
		i--
		dAtA[i] = 0x38
	}
	if m.DisableOutbound != nil {
		{
			size, err := m.DisableOutbound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ConfigOverride != nil {
		{
			size, err := m.ConfigOverride.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Topology != nil {
		{
			size, err := m.Topology.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Monitoring != nil {
		{
			size, err := m.Monitoring.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Logging != nil {
		{
			size, err := m.Logging.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogWindowDuration != nil {
		{
			size, err := m.LogWindowDuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PilotConfigSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotConfigSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PilotConfigSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubscribedResources) > 0 {
		for iNdEx := len(m.SubscribedResources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubscribedResources[iNdEx])
			copy(dAtA[i:], m.SubscribedResources[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.SubscribedResources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TargetPort != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.TargetPort))
		i--
		dAtA[i] = 0x20
	}
	if m.NodePort != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.NodePort))
		i--
		dAtA[i] = 0x18
	}
	if m.Port != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IncludeOutboundPorts) > 0 {
		i -= len(m.IncludeOutboundPorts)
		copy(dAtA[i:], m.IncludeOutboundPorts)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IncludeOutboundPorts)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.IncludeInboundPorts) > 0 {
		i -= len(m.IncludeInboundPorts)
		copy(dAtA[i:], m.IncludeInboundPorts)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IncludeInboundPorts)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.HoldApplicationUntilProxyStarts != nil {
		{
			size, err := m.HoldApplicationUntilProxyStarts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.Lifecycle != nil {
		{
			size, err := m.Lifecycle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.ExcludeOutboundPorts) > 0 {
		i -= len(m.ExcludeOutboundPorts)
		copy(dAtA[i:], m.ExcludeOutboundPorts)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeOutboundPorts)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.Tracer != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Tracer))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.StatusPort != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.StatusPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.ReadinessFailureThreshold != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessFailureThreshold))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.ReadinessPeriodSeconds != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessPeriodSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ReadinessInitialDelaySeconds != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessInitialDelaySeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Privileged != nil {
		{
			size, err := m.Privileged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.LogLevel) > 0 {
		i -= len(m.LogLevel)
		copy(dAtA[i:], m.LogLevel)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LogLevel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IncludeIPRanges) > 0 {
		i -= len(m.IncludeIPRanges)
		copy(dAtA[i:], m.IncludeIPRanges)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IncludeIPRanges)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ExcludeIPRanges) > 0 {
		i -= len(m.ExcludeIPRanges)
		copy(dAtA[i:], m.ExcludeIPRanges)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeIPRanges)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ExcludeInboundPorts) > 0 {
		i -= len(m.ExcludeInboundPorts)
		copy(dAtA[i:], m.ExcludeInboundPorts)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeInboundPorts)))
		i--
		dAtA[i] = 0x62
	}
	if m.EnableCoreDump != nil {
		{
			size, err := m.EnableCoreDump.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ComponentLogLevel) > 0 {
		i -= len(m.ComponentLogLevel)
		copy(dAtA[i:], m.ComponentLogLevel)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ComponentLogLevel)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClusterDomain) > 0 {
		i -= len(m.ClusterDomain)
		copy(dAtA[i:], m.ClusterDomain)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ClusterDomain)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AutoInject) > 0 {
		i -= len(m.AutoInject)
		copy(dAtA[i:], m.AutoInject)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.AutoInject)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *ProxyInitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyInitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyInitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcesRequestsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesRequestsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcesRequestsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Memory) > 0 {
		i -= len(m.Memory)
		copy(dAtA[i:], m.Memory)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Memory)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cpu) > 0 {
		i -= len(m.Cpu)
		copy(dAtA[i:], m.Cpu)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Cpu)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SDSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SDSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SDSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *SecretVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretVolume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretVolume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SecretName) > 0 {
		i -= len(m.SecretName)
		copy(dAtA[i:], m.SecretName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.SecretName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MountPath) > 0 {
		i -= len(m.MountPath)
		copy(dAtA[i:], m.MountPath)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.MountPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExternalPort != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ExternalPort))
		i--
		dAtA[i] = 0x10
	}
	if m.Annotations != nil {
		{
			size, err := m.Annotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SidecarInjectorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarInjectorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SidecarInjectorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultTemplates) > 0 {
		for iNdEx := len(m.DefaultTemplates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultTemplates[iNdEx])
			copy(dAtA[i:], m.DefaultTemplates[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.DefaultTemplates[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.Templates != nil {
		{
			size, err := m.Templates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.InjectionURL) > 0 {
		i -= len(m.InjectionURL)
		copy(dAtA[i:], m.InjectionURL)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InjectionURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ObjectSelector != nil {
		{
			size, err := m.ObjectSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.InjectedAnnotations != nil {
		{
			size, err := m.InjectedAnnotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.RewriteAppHTTPProbe != nil {
		{
			size, err := m.RewriteAppHTTPProbe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.AlwaysInjectSelector) > 0 {
		for iNdEx := len(m.AlwaysInjectSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AlwaysInjectSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.NeverInjectSelector) > 0 {
		for iNdEx := len(m.NeverInjectSelector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NeverInjectSelector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintValuesTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.UseLegacySelectors != nil {
		{
			size, err := m.UseLegacySelectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EnableNamespacesByDefault != nil {
		{
			size, err := m.EnableNamespacesByDefault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TracerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stackdriver != nil {
		{
			size, err := m.Stackdriver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Zipkin != nil {
		{
			size, err := m.Zipkin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Lightstep != nil {
		{
			size, err := m.Lightstep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Datadog != nil {
		{
			size, err := m.Datadog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracerDatadogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerDatadogConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracerDatadogConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracerLightStepConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerLightStepConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracerLightStepConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracerZipkinConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerZipkinConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracerZipkinConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracerStackdriverConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerStackdriverConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracerStackdriverConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxNumberOfMessageEvents != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MaxNumberOfMessageEvents))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxNumberOfAnnotations != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MaxNumberOfAnnotations))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxNumberOfAttributes != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MaxNumberOfAttributes))
		i--
		dAtA[i] = 0x10
	}
	if m.Debug != nil {
		{
			size, err := m.Debug.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnableIstioConfigCRDs != nil {
		{
			size, err := m.EnableIstioConfigCRDs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidationURL) > 0 {
		i -= len(m.ValidationURL)
		copy(dAtA[i:], m.ValidationURL)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ValidationURL)))
		i--
		dAtA[i] = 0x12
	}
	if m.EnableCRDTemplates != nil {
		{
			size, err := m.EnableCRDTemplates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IstiodRemoteConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstiodRemoteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IstiodRemoteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InjectionPath) > 0 {
		i -= len(m.InjectionPath)
		copy(dAtA[i:], m.InjectionPath)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InjectionPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InjectionURL) > 0 {
		i -= len(m.InjectionURL)
		copy(dAtA[i:], m.InjectionURL)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.InjectionURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Values) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Values) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Values) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mdp != nil {
		{
			size, err := m.Mdp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.Hsm != nil {
		{
			size, err := m.Hsm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DefaultRevision) > 0 {
		i -= len(m.DefaultRevision)
		copy(dAtA[i:], m.DefaultRevision)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.DefaultRevision)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RevisionTags) > 0 {
		for iNdEx := len(m.RevisionTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RevisionTags[iNdEx])
			copy(dAtA[i:], m.RevisionTags[iNdEx])
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.RevisionTags[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if m.IstiodRemote != nil {
		{
			size, err := m.IstiodRemote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.MeshConfig != nil {
		{
			size, err := m.MeshConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.Telemetry != nil {
		{
			size, err := m.Telemetry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.OwnerName) > 0 {
		i -= len(m.OwnerName)
		copy(dAtA[i:], m.OwnerName)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.OwnerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.IstioCni != nil {
		{
			size, err := m.IstioCni.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.SidecarInjectorWebhook != nil {
		{
			size, err := m.SidecarInjectorWebhook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Pilot != nil {
		{
			size, err := m.Pilot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Cni != nil {
		{
			size, err := m.Cni.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ZeroVPNConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroVPNConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroVPNConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Suffix) > 0 {
		i -= len(m.Suffix)
		copy(dAtA[i:], m.Suffix)
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Suffix)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IntOrString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntOrString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntOrString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StrVal != nil {
		{
			size, err := m.StrVal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IntVal != nil {
		{
			size, err := m.IntVal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintValuesTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintValuesTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovValuesTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ArchConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amd64 != 0 {
		n += 1 + sovValuesTypes(uint64(m.Amd64))
	}
	if m.Ppc64Le != 0 {
		n += 1 + sovValuesTypes(uint64(m.Ppc64Le))
	}
	if m.S390X != 0 {
		n += 1 + sovValuesTypes(uint64(m.S390X))
	}
	if m.Arm64 != 0 {
		n += 1 + sovValuesTypes(uint64(m.Arm64))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNIConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.PullPolicy)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CniBinDir)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CniConfDir)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CniConfFileName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.ExcludeNamespaces) > 0 {
		for _, s := range m.ExcludeNamespaces {
			l = len(s)
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.PodAnnotations != nil {
		l = m.PodAnnotations.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.PspClusterRole)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.LogLevel)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Repair != nil {
		l = m.Repair.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Chained != nil {
		l = m.Chained.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Taint != nil {
		l = m.Taint.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ResourceQuotas != nil {
		l = m.ResourceQuotas.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Privileged != nil {
		l = m.Privileged.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNITaintConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNIRepairConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.LabelPods {
		n += 2
	}
	l = len(m.CreateEvents)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DeletePods {
		n += 2
	}
	l = len(m.BrokenPodLabelKey)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.BrokenPodLabelValue)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.InitContainerName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceQuotas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Pods != 0 {
		n += 1 + sovValuesTypes(uint64(m.Pods))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CPUTargetUtilizationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetAverageUtilization != 0 {
		n += 1 + sovValuesTypes(uint64(m.TargetAverageUtilization))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DefaultPodDisruptionBudgetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DefaultResourcesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requests != nil {
		l = m.Requests.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled != nil {
		l = m.AutoscaleEnabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Env != nil {
		l = m.Env.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.NodeSelector != nil {
		l = m.NodeSelector.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.PodAnnotations != nil {
		l = m.PodAnnotations.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.PodAntiAffinityLabelSelector) > 0 {
		for _, e := range m.PodAntiAffinityLabelSelector {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.PodAntiAffinityTermLabelSelector) > 0 {
		for _, e := range m.PodAntiAffinityTermLabelSelector {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.SecretVolumes) > 0 {
		for _, e := range m.SecretVolumes {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.ServiceAnnotations != nil {
		l = m.ServiceAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Zvpn != nil {
		l = m.Zvpn.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.RollingMaxSurge != nil {
		l = m.RollingMaxSurge.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RollingMaxUnavailable != nil {
		l = m.RollingMaxUnavailable.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.ConfigVolumes) > 0 {
		for _, e := range m.ConfigVolumes {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.AdditionalContainers) > 0 {
		for _, e := range m.AdditionalContainers {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RunAsRoot != nil {
		l = m.RunAsRoot.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.InjectionTemplate)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ServiceAccount != nil {
		l = m.ServiceAccount.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewaysConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IstioEgressgateway != nil {
		l = m.IstioEgressgateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IstioIngressgateway != nil {
		l = m.IstioIngressgateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Arch != nil {
		l = m.Arch.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigValidation != nil {
		l = m.ConfigValidation.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DefaultNodeSelector != nil {
		l = m.DefaultNodeSelector.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DefaultPodDisruptionBudget != nil {
		l = m.DefaultPodDisruptionBudget.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DefaultResources != nil {
		l = m.DefaultResources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ImagePullPolicy)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IstioNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Logging != nil {
		l = m.Logging.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.MeshNetworks != nil {
		l = m.MeshNetworks.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.MultiCluster != nil {
		l = m.MultiCluster.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.OneNamespace != nil {
		l = m.OneNamespace.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ProxyInit != nil {
		l = m.ProxyInit.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Sds != nil {
		l = m.Sds.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Tracer != nil {
		l = m.Tracer.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.UseMCP != nil {
		l = m.UseMCP.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.LogAsJson != nil {
		l = m.LogAsJson.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.OmitSidecarInjectorConfigMap != nil {
		l = m.OmitSidecarInjectorConfigMap.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.OperatorManageWebhooks != nil {
		l = m.OperatorManageWebhooks.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.PodDNSSearchNamespaces) > 0 {
		for _, s := range m.PodDNSSearchNamespaces {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.RemotePilotAddress)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ConfigRootNamespace)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DefaultConfigVisibilitySettings) > 0 {
		for _, s := range m.DefaultConfigVisibilitySettings {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.MeshID)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Istiod != nil {
		l = m.Istiod.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DefaultTolerations) > 0 {
		for _, e := range m.DefaultTolerations {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.PilotCertProvider)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.JwtPolicy)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Sts != nil {
		l = m.Sts.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.MountMtlsCerts != nil {
		l = m.MountMtlsCerts.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CaAddress)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ExternalIstiod != nil {
		l = m.ExternalIstiod.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigCluster != nil {
		l = m.ConfigCluster.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CaName)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *STSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServicePort != 0 {
		n += 1 + sovValuesTypes(uint64(m.ServicePort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IstiodConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableAnalysis != nil {
		l = m.EnableAnalysis.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalLoggingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled != nil {
		l = m.AutoscaleEnabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.CustomService != nil {
		l = m.CustomService.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Env != nil {
		l = m.Env.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.NodeSelector != nil {
		l = m.NodeSelector.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.PodAnnotations != nil {
		l = m.PodAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.PodAntiAffinityLabelSelector) > 0 {
		for _, e := range m.PodAntiAffinityLabelSelector {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.PodAntiAffinityTermLabelSelector) > 0 {
		for _, e := range m.PodAntiAffinityTermLabelSelector {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.ReplicaCount != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.SecretVolumes) > 0 {
		for _, e := range m.SecretVolumes {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.ServiceAnnotations != nil {
		l = m.ServiceAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Zvpn != nil {
		l = m.Zvpn.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RollingMaxSurge != nil {
		l = m.RollingMaxSurge.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RollingMaxUnavailable != nil {
		l = m.RollingMaxUnavailable.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ExternalTrafficPolicy)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.IngressPorts) > 0 {
		for _, e := range m.IngressPorts {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.AdditionalContainers) > 0 {
		for _, e := range m.AdditionalContainers {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.ConfigVolumes) > 0 {
		for _, e := range m.ConfigVolumes {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RunAsRoot != nil {
		l = m.RunAsRoot.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.InjectionTemplate)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ServiceAccount != nil {
		l = m.ServiceAccount.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayZvpnConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MDPConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IstioNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.MdpNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.GlobalDomainSuffix)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IncludeEnvoyFilter != nil {
		l = m.IncludeEnvoyFilter.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutboundTrafficPolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovValuesTypes(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AutoscaleEnabled != nil {
		l = m.AutoscaleEnabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.TraceSampling != 0 {
		n += 9
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ConfigNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.NodeSelector != nil {
		l = m.NodeSelector.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		l = m.KeepaliveMaxServerConnectionAge.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DeploymentLabels != nil {
		l = m.DeploymentLabels.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigMap != nil {
		l = m.ConfigMap.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.UseMCP != nil {
		l = m.UseMCP.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Env != nil {
		l = m.Env.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RollingMaxSurge != nil {
		l = m.RollingMaxSurge.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.RollingMaxUnavailable != nil {
		l = m.RollingMaxUnavailable.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.EnableProtocolSniffingForOutbound != nil {
		l = m.EnableProtocolSniffingForOutbound.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.EnableProtocolSniffingForInbound != nil {
		l = m.EnableProtocolSniffingForInbound.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.PodAnnotations != nil {
		l = m.PodAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigSource != nil {
		l = m.ConfigSource.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.JwksResolverExtraRootCA)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Plugins) > 0 {
		for _, s := range m.Plugins {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.Hub)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.PodLabels != nil {
		l = m.PodLabels.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ServiceAnnotations != nil {
		l = m.ServiceAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.HsmKEKID)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.HsmPluginImage)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.HsmSlotLabel)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultClientImage)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultAuthPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultAuthRole)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultAuthJwtPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.VaultSecretPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotIngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IngressService)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IngressControllerMode != 0 {
		n += 1 + sovValuesTypes(uint64(m.IngressControllerMode))
	}
	l = len(m.IngressClass)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotPolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.V2 != nil {
		l = m.V2.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Prometheus != nil {
		l = m.Prometheus.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Stackdriver != nil {
		l = m.Stackdriver.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MetadataExchange != nil {
		l = m.MetadataExchange.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AccessLogPolicy != nil {
		l = m.AccessLogPolicy.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2MetadataExchangeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WasmEnabled != nil {
		l = m.WasmEnabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2PrometheusConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.WasmEnabled != nil {
		l = m.WasmEnabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigOverride != nil {
		l = m.ConfigOverride.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2PrometheusConfig_ConfigOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.InboundSidecar != nil {
		l = m.InboundSidecar.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.OutboundSidecar != nil {
		l = m.OutboundSidecar.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2StackDriverConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Logging != nil {
		l = m.Logging.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Monitoring != nil {
		l = m.Monitoring.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Topology != nil {
		l = m.Topology.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigOverride != nil {
		l = m.ConfigOverride.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DisableOutbound != nil {
		l = m.DisableOutbound.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.OutboundAccessLogging != 0 {
		n += 1 + sovValuesTypes(uint64(m.OutboundAccessLogging))
	}
	if m.InboundAccessLogging != 0 {
		n += 1 + sovValuesTypes(uint64(m.InboundAccessLogging))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryV2AccessLogPolicyFilterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.LogWindowDuration != nil {
		l = m.LogWindowDuration.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotConfigSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubscribedResources) > 0 {
		for _, s := range m.SubscribedResources {
			l = len(s)
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovValuesTypes(uint64(m.Port))
	}
	if m.NodePort != 0 {
		n += 1 + sovValuesTypes(uint64(m.NodePort))
	}
	if m.TargetPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.TargetPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AutoInject)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ClusterDomain)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ComponentLogLevel)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.EnableCoreDump != nil {
		l = m.EnableCoreDump.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ExcludeInboundPorts)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ExcludeIPRanges)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IncludeIPRanges)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.LogLevel)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Privileged != nil {
		l = m.Privileged.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ReadinessInitialDelaySeconds != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessInitialDelaySeconds))
	}
	if m.ReadinessPeriodSeconds != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessPeriodSeconds))
	}
	if m.ReadinessFailureThreshold != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessFailureThreshold))
	}
	if m.StatusPort != 0 {
		n += 2 + sovValuesTypes(uint64(m.StatusPort))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Tracer != 0 {
		n += 2 + sovValuesTypes(uint64(m.Tracer))
	}
	l = len(m.ExcludeOutboundPorts)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Lifecycle != nil {
		l = m.Lifecycle.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.HoldApplicationUntilProxyStarts != nil {
		l = m.HoldApplicationUntilProxyStarts.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IncludeInboundPorts)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IncludeOutboundPorts)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyInitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcesRequestsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SDSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretVolume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.SecretName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ExternalPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.ExternalPort))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarInjectorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableNamespacesByDefault != nil {
		l = m.EnableNamespacesByDefault.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.UseLegacySelectors != nil {
		l = m.UseLegacySelectors.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.NeverInjectSelector) > 0 {
		for _, e := range m.NeverInjectSelector {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.AlwaysInjectSelector) > 0 {
		for _, e := range m.AlwaysInjectSelector {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.RewriteAppHTTPProbe != nil {
		l = m.RewriteAppHTTPProbe.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.InjectedAnnotations != nil {
		l = m.InjectedAnnotations.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ObjectSelector != nil {
		l = m.ObjectSelector.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.InjectionURL)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Templates != nil {
		l = m.Templates.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DefaultTemplates) > 0 {
		for _, s := range m.DefaultTemplates {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datadog != nil {
		l = m.Datadog.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Lightstep != nil {
		l = m.Lightstep.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Zipkin != nil {
		l = m.Zipkin.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Stackdriver != nil {
		l = m.Stackdriver.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerDatadogConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerLightStepConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerZipkinConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerStackdriverConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MaxNumberOfAttributes != 0 {
		n += 1 + sovValuesTypes(uint64(m.MaxNumberOfAttributes))
	}
	if m.MaxNumberOfAnnotations != 0 {
		n += 1 + sovValuesTypes(uint64(m.MaxNumberOfAnnotations))
	}
	if m.MaxNumberOfMessageEvents != 0 {
		n += 1 + sovValuesTypes(uint64(m.MaxNumberOfMessageEvents))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaseConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableCRDTemplates != nil {
		l = m.EnableCRDTemplates.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ValidationURL)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.EnableIstioConfigCRDs != nil {
		l = m.EnableIstioConfigCRDs.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IstiodRemoteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InjectionURL)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.InjectionPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Values) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cni != nil {
		l = m.Cni.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Pilot != nil {
		l = m.Pilot.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.SidecarInjectorWebhook != nil {
		l = m.SidecarInjectorWebhook.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IstioCni != nil {
		l = m.IstioCni.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.OwnerName)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.MeshConfig != nil {
		l = m.MeshConfig.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Base != nil {
		l = m.Base.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.IstiodRemote != nil {
		l = m.IstiodRemote.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.RevisionTags) > 0 {
		for _, s := range m.RevisionTags {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	l = len(m.DefaultRevision)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Hsm != nil {
		l = m.Hsm.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Mdp != nil {
		l = m.Mdp.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroVPNConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntOrString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovValuesTypes(uint64(m.Type))
	}
	if m.IntVal != nil {
		l = m.IntVal.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.StrVal != nil {
		l = m.StrVal.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovValuesTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozValuesTypes(x uint64) (n int) {
	return sovValuesTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ArchConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amd64", wireType)
			}
			m.Amd64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amd64 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppc64Le", wireType)
			}
			m.Ppc64Le = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ppc64Le |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S390X", wireType)
			}
			m.S390X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S390X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arm64", wireType)
			}
			m.Arm64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arm64 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNIConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNIConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNIConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &types.Value{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniBinDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CniBinDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniConfDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CniConfDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniConfFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CniConfFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeNamespaces = append(m.ExcludeNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = &types.Struct{}
			}
			if err := m.PodAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspClusterRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PspClusterRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repair == nil {
				m.Repair = &CNIRepairConfig{}
			}
			if err := m.Repair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chained", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chained == nil {
				m.Chained = &types.BoolValue{}
			}
			if err := m.Chained.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Taint == nil {
				m.Taint = &CNITaintConfig{}
			}
			if err := m.Taint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceQuotas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceQuotas == nil {
				m.ResourceQuotas = &ResourceQuotas{}
			}
			if err := m.ResourceQuotas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileged == nil {
				m.Privileged = &types.BoolValue{}
			}
			if err := m.Privileged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNITaintConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNITaintConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNITaintConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNIRepairConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNIRepairConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNIRepairConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &types.Value{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelPods", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LabelPods = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateEvents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateEvents = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePods", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePods = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenPodLabelKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokenPodLabelKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenPodLabelValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokenPodLabelValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitContainerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceQuotas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceQuotas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceQuotas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			m.Pods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pods |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUTargetUtilizationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUTargetUtilizationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUTargetUtilizationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAverageUtilization", wireType)
			}
			m.TargetAverageUtilization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetAverageUtilization |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &types.Struct{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultPodDisruptionBudgetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultPodDisruptionBudgetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultPodDisruptionBudgetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultResourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultResourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultResourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = &ResourcesRequestsConfig{}
			}
			if err := m.Requests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoscaleEnabled == nil {
				m.AutoscaleEnabled = &types.BoolValue{}
			}
			if err := m.AutoscaleEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &types.Struct{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = &types.Struct{}
			}
			if err := m.NodeSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = &types.Struct{}
			}
			if err := m.PodAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAntiAffinityLabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodAntiAffinityLabelSelector = append(m.PodAntiAffinityLabelSelector, &types.Struct{})
			if err := m.PodAntiAffinityLabelSelector[len(m.PodAntiAffinityLabelSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAntiAffinityTermLabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodAntiAffinityTermLabelSelector = append(m.PodAntiAffinityTermLabelSelector, &types.Struct{})
			if err := m.PodAntiAffinityTermLabelSelector[len(m.PodAntiAffinityTermLabelSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortsConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVolumes = append(m.SecretVolumes, &SecretVolume{})
			if err := m.SecretVolumes[len(m.SecretVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAnnotations == nil {
				m.ServiceAnnotations = &types.Struct{}
			}
			if err := m.ServiceAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zvpn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zvpn == nil {
				m.Zvpn = &ZeroVPNConfig{}
			}
			if err := m.Zvpn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &types.Struct{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxSurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxSurge == nil {
				m.RollingMaxSurge = &IntOrString{}
			}
			if err := m.RollingMaxSurge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxUnavailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxUnavailable == nil {
				m.RollingMaxUnavailable = &IntOrString{}
			}
			if err := m.RollingMaxUnavailable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigVolumes = append(m.ConfigVolumes, &types.Struct{})
			if err := m.ConfigVolumes[len(m.ConfigVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalContainers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalContainers = append(m.AdditionalContainers, &types.Struct{})
			if err := m.AdditionalContainers[len(m.AdditionalContainers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunAsRoot == nil {
				m.RunAsRoot = &types.BoolValue{}
			}
			if err := m.RunAsRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectionTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InjectionTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAccount == nil {
				m.ServiceAccount = &ServiceAccount{}
			}
			if err := m.ServiceAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewaysConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewaysConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewaysConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioEgressgateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioEgressgateway == nil {
				m.IstioEgressgateway = &EgressGatewayConfig{}
			}
			if err := m.IstioEgressgateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioIngressgateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioIngressgateway == nil {
				m.IstioIngressgateway = &IngressGatewayConfig{}
			}
			if err := m.IstioIngressgateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arch == nil {
				m.Arch = &ArchConfig{}
			}
			if err := m.Arch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigValidation == nil {
				m.ConfigValidation = &types.BoolValue{}
			}
			if err := m.ConfigValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultNodeSelector == nil {
				m.DefaultNodeSelector = &types.Struct{}
			}
			if err := m.DefaultNodeSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultPodDisruptionBudget == nil {
				m.DefaultPodDisruptionBudget = &DefaultPodDisruptionBudgetConfig{}
			}
			if err := m.DefaultPodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultResources == nil {
				m.DefaultResources = &DefaultResourcesConfig{}
			}
			if err := m.DefaultResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IstioNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Logging == nil {
				m.Logging = &GlobalLoggingConfig{}
			}
			if err := m.Logging.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshNetworks == nil {
				m.MeshNetworks = &types.Struct{}
			}
			if err := m.MeshNetworks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiCluster == nil {
				m.MultiCluster = &MultiClusterConfig{}
			}
			if err := m.MultiCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneNamespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OneNamespace == nil {
				m.OneNamespace = &types.BoolValue{}
			}
			if err := m.OneNamespace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ProxyConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyInit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyInit == nil {
				m.ProxyInit = &ProxyInitConfig{}
			}
			if err := m.ProxyInit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sds == nil {
				m.Sds = &SDSConfig{}
			}
			if err := m.Sds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &types.Value{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracer == nil {
				m.Tracer = &TracerConfig{}
			}
			if err := m.Tracer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseMCP == nil {
				m.UseMCP = &types.BoolValue{}
			}
			if err := m.UseMCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogAsJson", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogAsJson == nil {
				m.LogAsJson = &types.BoolValue{}
			}
			if err := m.LogAsJson.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OmitSidecarInjectorConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OmitSidecarInjectorConfigMap == nil {
				m.OmitSidecarInjectorConfigMap = &types.BoolValue{}
			}
			if err := m.OmitSidecarInjectorConfigMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorManageWebhooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OperatorManageWebhooks == nil {
				m.OperatorManageWebhooks = &types.BoolValue{}
			}
			if err := m.OperatorManageWebhooks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDNSSearchNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodDNSSearchNamespaces = append(m.PodDNSSearchNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePilotAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePilotAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigRootNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigRootNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfigVisibilitySettings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultConfigVisibilitySettings = append(m.DefaultConfigVisibilitySettings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeshID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Istiod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Istiod == nil {
				m.Istiod = &IstiodConfig{}
			}
			if err := m.Istiod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultTolerations = append(m.DefaultTolerations, &types.Struct{})
			if err := m.DefaultTolerations[len(m.DefaultTolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PilotCertProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PilotCertProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwtPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwtPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sts == nil {
				m.Sts = &STSConfig{}
			}
			if err := m.Sts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountMtlsCerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MountMtlsCerts == nil {
				m.MountMtlsCerts = &types.BoolValue{}
			}
			if err := m.MountMtlsCerts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIstiod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalIstiod == nil {
				m.ExternalIstiod = &types.BoolValue{}
			}
			if err := m.ExternalIstiod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigCluster == nil {
				m.ConfigCluster = &types.BoolValue{}
			}
			if err := m.ConfigCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *STSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: STSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: STSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IstiodConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstiodConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstiodConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAnalysis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableAnalysis == nil {
				m.EnableAnalysis = &types.BoolValue{}
			}
			if err := m.EnableAnalysis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalLoggingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalLoggingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalLoggingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoscaleEnabled == nil {
				m.AutoscaleEnabled = &types.BoolValue{}
			}
			if err := m.AutoscaleEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomService == nil {
				m.CustomService = &types.BoolValue{}
			}
			if err := m.CustomService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &types.Struct{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = &types.Struct{}
			}
			if err := m.NodeSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = &types.Struct{}
			}
			if err := m.PodAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAntiAffinityLabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodAntiAffinityLabelSelector = append(m.PodAntiAffinityLabelSelector, &types.Struct{})
			if err := m.PodAntiAffinityLabelSelector[len(m.PodAntiAffinityLabelSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAntiAffinityTermLabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodAntiAffinityTermLabelSelector = append(m.PodAntiAffinityTermLabelSelector, &types.Struct{})
			if err := m.PodAntiAffinityTermLabelSelector[len(m.PodAntiAffinityTermLabelSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortsConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &types.Struct{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVolumes = append(m.SecretVolumes, &SecretVolume{})
			if err := m.SecretVolumes[len(m.SecretVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAnnotations == nil {
				m.ServiceAnnotations = &types.Struct{}
			}
			if err := m.ServiceAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zvpn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zvpn == nil {
				m.Zvpn = &IngressGatewayZvpnConfig{}
			}
			if err := m.Zvpn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxSurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxSurge == nil {
				m.RollingMaxSurge = &IntOrString{}
			}
			if err := m.RollingMaxSurge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxUnavailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxUnavailable == nil {
				m.RollingMaxUnavailable = &IntOrString{}
			}
			if err := m.RollingMaxUnavailable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTrafficPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &types.Struct{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressPorts = append(m.IngressPorts, &types.Struct{})
			if err := m.IngressPorts[len(m.IngressPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalContainers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalContainers = append(m.AdditionalContainers, &types.Struct{})
			if err := m.AdditionalContainers[len(m.AdditionalContainers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigVolumes = append(m.ConfigVolumes, &types.Struct{})
			if err := m.ConfigVolumes[len(m.ConfigVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunAsRoot == nil {
				m.RunAsRoot = &types.BoolValue{}
			}
			if err := m.RunAsRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectionTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InjectionTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAccount == nil {
				m.ServiceAccount = &ServiceAccount{}
			}
			if err := m.ServiceAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayZvpnConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayZvpnConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayZvpnConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MDPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MDPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MDPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IstioNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MdpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MdpNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalDomainSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalDomainSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeEnvoyFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncludeEnvoyFilter == nil {
				m.IncludeEnvoyFilter = &types.BoolValue{}
			}
			if err := m.IncludeEnvoyFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutboundTrafficPolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutboundTrafficPolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutboundTrafficPolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= OutboundTrafficPolicyConfig_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoscaleEnabled == nil {
				m.AutoscaleEnabled = &types.BoolValue{}
			}
			if err := m.AutoscaleEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceSampling", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TraceSampling = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = &types.Struct{}
			}
			if err := m.NodeSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveMaxServerConnectionAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeepaliveMaxServerConnectionAge == nil {
				m.KeepaliveMaxServerConnectionAge = &types.Duration{}
			}
			if err := m.KeepaliveMaxServerConnectionAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentLabels == nil {
				m.DeploymentLabels = &types.Struct{}
			}
			if err := m.DeploymentLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMap == nil {
				m.ConfigMap = &types.BoolValue{}
			}
			if err := m.ConfigMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseMCP == nil {
				m.UseMCP = &types.BoolValue{}
			}
			if err := m.UseMCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &types.Struct{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxSurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxSurge == nil {
				m.RollingMaxSurge = &IntOrString{}
			}
			if err := m.RollingMaxSurge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollingMaxUnavailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollingMaxUnavailable == nil {
				m.RollingMaxUnavailable = &IntOrString{}
			}
			if err := m.RollingMaxUnavailable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &types.Struct{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProtocolSniffingForOutbound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableProtocolSniffingForOutbound == nil {
				m.EnableProtocolSniffingForOutbound = &types.BoolValue{}
			}
			if err := m.EnableProtocolSniffingForOutbound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProtocolSniffingForInbound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableProtocolSniffingForInbound == nil {
				m.EnableProtocolSniffingForInbound = &types.BoolValue{}
			}
			if err := m.EnableProtocolSniffingForInbound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = &types.Struct{}
			}
			if err := m.PodAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigSource == nil {
				m.ConfigSource = &PilotConfigSource{}
			}
			if err := m.ConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwksResolverExtraRootCA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwksResolverExtraRootCA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plugins = append(m.Plugins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &types.Value{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodLabels == nil {
				m.PodLabels = &types.Struct{}
			}
			if err := m.PodLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAnnotations == nil {
				m.ServiceAnnotations = &types.Struct{}
			}
			if err := m.ServiceAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HsmKEKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HsmKEKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HsmPluginImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HsmPluginImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HsmSlotLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HsmSlotLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultClientImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultClientImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAuthPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAuthPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAuthRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAuthRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAuthJwtPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAuthJwtPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultSecretPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotIngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotIngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotIngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressControllerMode", wireType)
			}
			m.IngressControllerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressControllerMode |= IngressControllerMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotPolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotPolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotPolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V2 == nil {
				m.V2 = &TelemetryV2Config{}
			}
			if err := m.V2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryV2Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryV2Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prometheus == nil {
				m.Prometheus = &TelemetryV2PrometheusConfig{}
			}
			if err := m.Prometheus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stackdriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stackdriver == nil {
				m.Stackdriver = &TelemetryV2StackDriverConfig{}
			}
			if err := m.Stackdriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataExchange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataExchange == nil {
				m.MetadataExchange = &TelemetryV2MetadataExchangeConfig{}
			}
			if err := m.MetadataExchange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessLogPolicy == nil {
				m.AccessLogPolicy = &TelemetryV2AccessLogPolicyFilterConfig{}
			}
			if err := m.AccessLogPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2MetadataExchangeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryV2MetadataExchangeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryV2MetadataExchangeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasmEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WasmEnabled == nil {
				m.WasmEnabled = &types.BoolValue{}
			}
			if err := m.WasmEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2PrometheusConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryV2PrometheusConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryV2PrometheusConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasmEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WasmEnabled == nil {
				m.WasmEnabled = &types.BoolValue{}
			}
			if err := m.WasmEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigOverride == nil {
				m.ConfigOverride = &TelemetryV2PrometheusConfig_ConfigOverride{}
			}
			if err := m.ConfigOverride.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2PrometheusConfig_ConfigOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &types.Struct{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InboundSidecar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InboundSidecar == nil {
				m.InboundSidecar = &types.Struct{}
			}
			if err := m.InboundSidecar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundSidecar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutboundSidecar == nil {
				m.OutboundSidecar = &types.Struct{}
			}
			if err := m.OutboundSidecar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2StackDriverConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryV2StackDriverConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryV2StackDriverConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Logging == nil {
				m.Logging = &types.BoolValue{}
			}
			if err := m.Logging.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitoring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monitoring == nil {
				m.Monitoring = &types.BoolValue{}
			}
			if err := m.Monitoring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topology", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topology == nil {
				m.Topology = &types.BoolValue{}
			}
			if err := m.Topology.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigOverride == nil {
				m.ConfigOverride = &types.Struct{}
			}
			if err := m.ConfigOverride.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOutbound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisableOutbound == nil {
				m.DisableOutbound = &types.BoolValue{}
			}
			if err := m.DisableOutbound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundAccessLogging", wireType)
			}
			m.OutboundAccessLogging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutboundAccessLogging |= TelemetryV2StackDriverConfig_AccessLogging(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InboundAccessLogging", wireType)
			}
			m.InboundAccessLogging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InboundAccessLogging |= TelemetryV2StackDriverConfig_AccessLogging(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryV2AccessLogPolicyFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryV2AccessLogPolicyFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryV2AccessLogPolicyFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogWindowDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogWindowDuration == nil {
				m.LogWindowDuration = &types.Duration{}
			}
			if err := m.LogWindowDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotConfigSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotConfigSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotConfigSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribedResources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscribedResources = append(m.SubscribedResources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			m.TargetPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoInject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoInject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComponentLogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComponentLogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCoreDump", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableCoreDump == nil {
				m.EnableCoreDump = &types.BoolValue{}
			}
			if err := m.EnableCoreDump.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeInboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeIPRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeIPRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeIPRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeIPRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileged == nil {
				m.Privileged = &types.BoolValue{}
			}
			if err := m.Privileged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessInitialDelaySeconds", wireType)
			}
			m.ReadinessInitialDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessInitialDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessPeriodSeconds", wireType)
			}
			m.ReadinessPeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessPeriodSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessFailureThreshold", wireType)
			}
			m.ReadinessFailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessFailureThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusPort", wireType)
			}
			m.StatusPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracer", wireType)
			}
			m.Tracer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tracer |= Tracer(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeOutboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeOutboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifecycle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifecycle == nil {
				m.Lifecycle = &types.Struct{}
			}
			if err := m.Lifecycle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldApplicationUntilProxyStarts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HoldApplicationUntilProxyStarts == nil {
				m.HoldApplicationUntilProxyStarts = &types.BoolValue{}
			}
			if err := m.HoldApplicationUntilProxyStarts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeInboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeOutboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeOutboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyInitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyInitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyInitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcesRequestsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesRequestsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesRequestsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SDSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SDSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SDSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Struct{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &types.Struct{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarInjectorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarInjectorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarInjectorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableNamespacesByDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableNamespacesByDefault == nil {
				m.EnableNamespacesByDefault = &types.BoolValue{}
			}
			if err := m.EnableNamespacesByDefault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLegacySelectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseLegacySelectors == nil {
				m.UseLegacySelectors = &types.BoolValue{}
			}
			if err := m.UseLegacySelectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeverInjectSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeverInjectSelector = append(m.NeverInjectSelector, &types.Struct{})
			if err := m.NeverInjectSelector[len(m.NeverInjectSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysInjectSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlwaysInjectSelector = append(m.AlwaysInjectSelector, &types.Struct{})
			if err := m.AlwaysInjectSelector[len(m.AlwaysInjectSelector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteAppHTTPProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewriteAppHTTPProbe == nil {
				m.RewriteAppHTTPProbe = &types.BoolValue{}
			}
			if err := m.RewriteAppHTTPProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectedAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InjectedAnnotations == nil {
				m.InjectedAnnotations = &types.Struct{}
			}
			if err := m.InjectedAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectSelector == nil {
				m.ObjectSelector = &types.Struct{}
			}
			if err := m.ObjectSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectionURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InjectionURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Templates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Templates == nil {
				m.Templates = &types.Struct{}
			}
			if err := m.Templates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTemplates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultTemplates = append(m.DefaultTemplates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datadog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datadog == nil {
				m.Datadog = &TracerDatadogConfig{}
			}
			if err := m.Datadog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lightstep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lightstep == nil {
				m.Lightstep = &TracerLightStepConfig{}
			}
			if err := m.Lightstep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zipkin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zipkin == nil {
				m.Zipkin = &TracerZipkinConfig{}
			}
			if err := m.Zipkin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stackdriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stackdriver == nil {
				m.Stackdriver = &TracerStackdriverConfig{}
			}
			if err := m.Stackdriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerDatadogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerDatadogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerDatadogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerLightStepConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerLightStepConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerLightStepConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerZipkinConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerZipkinConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerZipkinConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerStackdriverConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerStackdriverConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerStackdriverConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &types.BoolValue{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfAttributes", wireType)
			}
			m.MaxNumberOfAttributes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfAttributes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfAnnotations", wireType)
			}
			m.MaxNumberOfAnnotations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfAnnotations |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfMessageEvents", wireType)
			}
			m.MaxNumberOfMessageEvents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfMessageEvents |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCRDTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableCRDTemplates == nil {
				m.EnableCRDTemplates = &types.BoolValue{}
			}
			if err := m.EnableCRDTemplates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidationURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIstioConfigCRDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableIstioConfigCRDs == nil {
				m.EnableIstioConfigCRDs = &types.BoolValue{}
			}
			if err := m.EnableIstioConfigCRDs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IstiodRemoteConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstiodRemoteConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstiodRemoteConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectionURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InjectionURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectionPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InjectionPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Values) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Values: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Values: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cni == nil {
				m.Cni = &CNIConfig{}
			}
			if err := m.Cni.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &GatewaysConfig{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &GlobalConfig{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pilot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pilot == nil {
				m.Pilot = &PilotConfig{}
			}
			if err := m.Pilot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarInjectorWebhook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarInjectorWebhook == nil {
				m.SidecarInjectorWebhook = &SidecarInjectorConfig{}
			}
			if err := m.SidecarInjectorWebhook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioCni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioCni == nil {
				m.IstioCni = &CNIConfig{}
			}
			if err := m.IstioCni.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryConfig{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshConfig == nil {
				m.MeshConfig = &types.Value{}
			}
			if err := m.MeshConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &BaseConfig{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstiodRemote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstiodRemote == nil {
				m.IstiodRemote = &IstiodRemoteConfig{}
			}
			if err := m.IstiodRemote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevisionTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevisionTags = append(m.RevisionTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hsm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hsm == nil {
				m.Hsm = &HSMConfig{}
			}
			if err := m.Hsm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mdp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mdp == nil {
				m.Mdp = &MDPConfig{}
			}
			if err := m.Mdp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroVPNConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroVPNConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroVPNConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntOrString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntOrString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntOrString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntVal == nil {
				m.IntVal = &types.Int32Value{}
			}
			if err := m.IntVal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StrVal == nil {
				m.StrVal = &types.StringValue{}
			}
			if err := m.StrVal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipValuesTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthValuesTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupValuesTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthValuesTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthValuesTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowValuesTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupValuesTypes = fmt.Errorf("proto: unexpected end of group")
)
